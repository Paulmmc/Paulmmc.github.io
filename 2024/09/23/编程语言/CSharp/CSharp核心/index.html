<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>CSharp核心 | Paul的博客</title>
  <meta name="keywords" content=" CSharp ">
  <meta name="description" content="CSharp核心 | Paul的博客">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="知识点一 概述UGUI是 Unity 引擎自带的UI系统官方称之为：Unity UI是目前 Unity商业游戏开发中使用最广泛的UI系统开发解决方案它是基于 Unity 游戏对象的 UI系统，只能用来做游戏 UI功能不能用于开发 Unity 编辑器中内置的用户界面 知识点二 六大基础组件一、Canvas 渲染模式的控制1.Canvas 组件用来干啥Canvas 的意思是画布它是 UGUI 中所有">
<meta property="og:type" content="article">
<meta property="og:title" content="UGUI">
<meta property="og:url" content="https://paulmmc.github.io/2024/10/05/Unity%E7%AC%94%E8%AE%B0/UGUI/UGUI/index.html">
<meta property="og:site_name" content="Paul的博客">
<meta property="og:description" content="知识点一 概述UGUI是 Unity 引擎自带的UI系统官方称之为：Unity UI是目前 Unity商业游戏开发中使用最广泛的UI系统开发解决方案它是基于 Unity 游戏对象的 UI系统，只能用来做游戏 UI功能不能用于开发 Unity 编辑器中内置的用户界面 知识点二 六大基础组件一、Canvas 渲染模式的控制1.Canvas 组件用来干啥Canvas 的意思是画布它是 UGUI 中所有">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-10-05T08:23:45.000Z">
<meta property="article:modified_time" content="2024-10-05T09:25:48.801Z">
<meta property="article:author" content="Paul">
<meta property="article:tag" content="UI">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 7.3.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>Paul</span>
</div>

<div class="icon">
    
        
    
        
            <a title="github"
               href="https://github.com/Paulmmc"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
            <a title="email"
               href="mailto:3095627551@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=3095627551&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(19)</small>
            
        </div>
    </li>
    
        
            
                
    <li>
        <div data-rel="Unity笔记">
            <i class="fold iconfont icon-right"></i>
            Unity笔记
            <small>(10)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="Unity笔记&lt;---&gt;Unity核心">
            
            Unity核心
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Unity笔记&lt;---&gt;Unity基础">
            
            Unity基础
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Unity笔记&lt;---&gt;Unity进阶">
            
            Unity进阶
            <small>(7)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Unity笔记&lt;---&gt;Unity入门">
            
            Unity入门
            <small>(1)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="理论基础">
            <i class="fold iconfont icon-right"></i>
            理论基础
            <small>(6)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="理论基础&lt;---&gt;编程语言">
            <i class="fold iconfont icon-right"></i>
            编程语言
            <small>(6)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="理论基础&lt;---&gt;编程语言&lt;---&gt;CSharp">
            
            CSharp
            <small>(4)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="CoscosCretor笔记">
            
            CoscosCretor笔记
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="UI">
            
            UI
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="19">
<input type="hidden" id="yelog_site_word_count" value="81k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>c++</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>cpp</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>CSharp</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>UI</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Unity</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="全部文章 UI "
           href="/2024/10/05/Unity%E7%AC%94%E8%AE%B0/UGUI/UGUI/"
           data-tag="UI"
           data-author="" >
            <span class="post-title" title="UGUI">UGUI</span>
            <span class="post-date" title="2024-10-05 16:23:45">2024/10/05</span>
        </a>
        
        
        <a  class="全部文章 Unity笔记 Unity核心 "
           href="/2024/10/05/Unity%E7%AC%94%E8%AE%B0/Unity%E6%A0%B8%E5%BF%83/"
           data-tag="Unity"
           data-author="" >
            <span class="post-title" title="Unity核心">Unity核心</span>
            <span class="post-date" title="2024-10-05 15:53:05">2024/10/05</span>
        </a>
        
        
        <a  class="全部文章 Unity笔记 Unity基础 "
           href="/2024/10/04/Unity%E7%AC%94%E8%AE%B0/Unity%E5%9F%BA%E7%A1%80/"
           data-tag="Unity"
           data-author="" >
            <span class="post-title" title="Unity基础">Unity基础</span>
            <span class="post-date" title="2024-10-04 22:30:55">2024/10/04</span>
        </a>
        
        
        <a  class="全部文章 Unity笔记 Unity入门 "
           href="/2024/09/27/Unity%E7%AC%94%E8%AE%B0/Unity%E5%85%A5%E9%97%A8/"
           data-tag="Unity"
           data-author="" >
            <span class="post-title" title="Unity入门">Unity入门</span>
            <span class="post-date" title="2024-09-27 23:19:29">2024/09/27</span>
        </a>
        
        
        <a  class="全部文章 理论基础 编程语言 CSharp "
           href="/2024/09/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/CSharp/CSharp%E8%BF%9B%E9%98%B6/"
           data-tag="CSharp"
           data-author="" >
            <span class="post-title" title="CSharp进阶">CSharp进阶</span>
            <span class="post-date" title="2024-09-24 23:02:43">2024/09/24</span>
        </a>
        
        
        <a  class="全部文章 理论基础 编程语言 CSharp "
           href="/2024/09/23/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/CSharp/CSharp%E6%A0%B8%E5%BF%83/"
           data-tag="CSharp"
           data-author="" >
            <span class="post-title" title="CSharp核心">CSharp核心</span>
            <span class="post-date" title="2024-09-23 23:16:21">2024/09/23</span>
        </a>
        
        
        <a  class="全部文章 理论基础 编程语言 CSharp "
           href="/2024/09/23/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/CSharp/CSharp%E5%9F%BA%E7%A1%80/"
           data-tag="CSharp"
           data-author="" >
            <span class="post-title" title="CSharp基础">CSharp基础</span>
            <span class="post-date" title="2024-09-23 22:07:32">2024/09/23</span>
        </a>
        
        
        <a  class="全部文章 理论基础 编程语言 CSharp "
           href="/2024/09/23/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/CSharp/CSharp%E5%85%A5%E9%97%A8/"
           data-tag="CSharp"
           data-author="" >
            <span class="post-title" title="CSharp入门">CSharp入门</span>
            <span class="post-date" title="2024-09-23 20:18:42">2024/09/23</span>
        </a>
        
        
        <a  class="全部文章 Unity笔记 Unity进阶 "
           href="/2024/09/23/Unity%E7%AC%94%E8%AE%B0/Unity%E8%BF%9B%E9%98%B6/InputSystem/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="InputSystem">InputSystem</span>
            <span class="post-date" title="2024-09-23 18:11:34">2024/09/23</span>
        </a>
        
        
        <a  class="全部文章 理论基础 编程语言 "
           href="/2024/09/23/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/C++/"
           data-tag="cpp,c++"
           data-author="" >
            <span class="post-title" title="C++">C++</span>
            <span class="post-date" title="2024-09-23 18:00:16">2024/09/23</span>
        </a>
        
        
        <a  class="全部文章 CoscosCretor笔记 "
           href="/2024/09/23/CocosCreator%E7%AC%94%E8%AE%B0/TS/TypeScript%E8%AF%AD%E8%A8%80/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="TypeScript语言">TypeScript语言</span>
            <span class="post-date" title="2024-09-23 18:00:16">2024/09/23</span>
        </a>
        
        
        <a  class="全部文章 Unity笔记 Unity进阶 "
           href="/2024/09/23/Unity%E7%AC%94%E8%AE%B0/Unity%E8%BF%9B%E9%98%B6/Excel%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Excel数据读取">Excel数据读取</span>
            <span class="post-date" title="2024-09-23 18:00:16">2024/09/23</span>
        </a>
        
        
        <a  class="全部文章 Unity笔记 Unity进阶 "
           href="/2024/09/23/Unity%E7%AC%94%E8%AE%B0/Unity%E8%BF%9B%E9%98%B6/GameFramework/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="GameFramework">GameFramework</span>
            <span class="post-date" title="2024-09-23 18:00:16">2024/09/23</span>
        </a>
        
        
        <a  class="全部文章 Unity笔记 Unity进阶 "
           href="/2024/09/23/Unity%E7%AC%94%E8%AE%B0/Unity%E8%BF%9B%E9%98%B6/Unity%E4%B8%AD%E7%9A%84MVC%E6%80%9D%E6%83%B3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Unity中的MVC思想">Unity中的MVC思想</span>
            <span class="post-date" title="2024-09-23 18:00:16">2024/09/23</span>
        </a>
        
        
        <a  class="全部文章 Unity笔记 Unity进阶 "
           href="/2024/09/23/Unity%E7%AC%94%E8%AE%B0/Unity%E8%BF%9B%E9%98%B6/Unity%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%8B2%E8%BF%9B%E5%88%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Unity数据持久化之2进制">Unity数据持久化之2进制</span>
            <span class="post-date" title="2024-09-23 18:00:16">2024/09/23</span>
        </a>
        
        
        <a  class="全部文章 Unity笔记 Unity进阶 "
           href="/2024/09/23/Unity%E7%AC%94%E8%AE%B0/Unity%E8%BF%9B%E9%98%B6/Unity%E7%BC%96%E8%BE%91%E5%99%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Unity编辑器">Unity编辑器</span>
            <span class="post-date" title="2024-09-23 18:00:16">2024/09/23</span>
        </a>
        
        
        <a  class="全部文章 Unity笔记 Unity进阶 "
           href="/2024/09/23/Unity%E7%AC%94%E8%AE%B0/Unity%E8%BF%9B%E9%98%B6/Unity%E7%BD%91%E7%BB%9C%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Unity网络开发基础">Unity网络开发基础</span>
            <span class="post-date" title="2024-09-23 18:00:16">2024/09/23</span>
        </a>
        
        
        <a  class="全部文章 理论基础 编程语言 "
           href="/2024/09/23/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/TypeScript/TypeScript%E8%AF%AD%E8%A8%80/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="TypeScript">TypeScript</span>
            <span class="post-date" title="2024-09-23 18:00:16">2024/09/23</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2024/09/21/hello-world/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Hello World">Hello World</span>
            <span class="post-date" title="2024-09-21 00:02:38">2024/09/21</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-编程语言/CSharp/CSharp核心" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">CSharp核心</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="理论基础">理论基础</a> > 
            
            <a  data-rel="理论基础&lt;---&gt;编程语言">编程语言</a> > 
            
            <a  data-rel="理论基础&lt;---&gt;编程语言&lt;---&gt;CSharp">CSharp</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color2">CSharp</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2024-09-24 22:54:23'>2024-09-23 23:16</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:10.7k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E5%B0%81%E8%A3%85"><span class="toc-text">知识点一 面向对象三大特性————封装</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-text">一、类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB"><span class="toc-text">1.什么是类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%B1%BB%E7%94%B3%E6%98%8E%E5%9C%A8%E5%93%AA%E9%87%8C"><span class="toc-text">2.类申明在哪里</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%B1%BB%E7%94%B3%E6%98%8E%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-text">3.类申明的语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%B1%BB%E7%94%B3%E6%98%8E%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="toc-text">4.类申明的实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="toc-text">5.什么是类对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-text">6.实例化对象的基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1"><span class="toc-text">7.实例化对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">二、成员变量和访问修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-text">1.成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">2.访问修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%88%9D%E5%A7%8B%E5%80%BC"><span class="toc-text">3.成员变量的使用和初始值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-text">三、成员方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E7%94%B3%E6%98%8E"><span class="toc-text">1.成员方法申明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">2.成员方法的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-text">四、构造函数，析构函数和垃圾回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">1.构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%89%B9%E6%AE%8A%E5%86%99%E6%B3%95%EF%BC%88%E5%8F%AF%E4%BB%A5%E5%A4%8D%E7%94%A8%E4%BB%A3%E7%A0%81%EF%BC%89"><span class="toc-text">2.构造函数特殊写法（可以复用代码）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">3.析构函数（了解）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-text">4.垃圾回收机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7"><span class="toc-text">五、成员属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">1.成员属性的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-text">2.成员属性的基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">3.成员属性的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7%E4%B8%AD%EF%BC%8Cget%E5%92%8Cset%E5%8F%AF%E4%BB%A5%E8%AE%BE%E7%BD%AE%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">4.成员属性中，get和set可以设置访问修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-get%E5%92%8Cset%E5%8F%AF%E4%BB%A5%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA"><span class="toc-text">5.get和set可以只有一个</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%87%AA%E5%8A%A8%E5%B1%9E%E6%80%A7"><span class="toc-text">6.自动属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E7%B4%A2%E5%BC%95%E5%99%A8"><span class="toc-text">六、索引器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">1.基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AF%AD%E6%B3%95"><span class="toc-text">2.语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%B4%A2%E5%BC%95%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">3.索引器的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%B4%A2%E5%BC%95%E5%99%A8%E4%B8%AD%E5%8F%AF%E4%BB%A5%E5%86%99%E9%80%BB%E8%BE%91"><span class="toc-text">4.索引器中可以写逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%B4%A2%E5%BC%95%E5%99%A8%E5%8F%AF%E4%BB%A5%E9%87%8D%E8%BD%BD"><span class="toc-text">5.索引器可以重载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-text">七、静态成员</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">1.静态成员的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%97%A9%E5%B7%B2%E5%87%BA%E7%8E%B0%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-text">2.早已出现的静态成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-text">3.自定义静态成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">4.静态成员的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8"><span class="toc-text">5.为什么静态成员可以直接使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0%E4%B8%AD%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-text">6.静态函数中不能使用非静态成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E9%9D%9E%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-text">7.非静态函数可以使用静态成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">8.静态成员的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%B8%B8%E9%87%8F%E5%92%8C%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-text">9.常量和静态变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E9%9D%99%E6%80%81%E7%B1%BB%E5%92%8C%E9%9D%99%E6%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">八、静态类和静态构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%9D%99%E6%80%81%E7%B1%BB"><span class="toc-text">1.静态类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%9D%99%E6%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88%E5%B0%91%E7%94%A8%EF%BC%89"><span class="toc-text">2.静态构造函数（少用）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E6%8B%93%E5%B1%95%E6%96%B9%E6%B3%95"><span class="toc-text">九、拓展方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-1"><span class="toc-text">1.基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-text">2.基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AE%9E%E4%BE%8B"><span class="toc-text">3.实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8"><span class="toc-text">4.使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%B8%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E6%8B%93%E5%B1%95%E6%96%B9%E6%B3%95"><span class="toc-text">5.为自定义类型拓展方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-text">十、运算符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-2"><span class="toc-text">1.基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-1"><span class="toc-text">2.基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AE%9E%E4%BE%8B-1"><span class="toc-text">3.实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8-1"><span class="toc-text">4.使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%8F%AF%E9%87%8D%E8%BD%BD%E5%92%8C%E4%B8%8D%E5%8F%AF%E9%87%8D%E8%BD%BD%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">5.可重载和不可重载的运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E5%88%86%E9%83%A8%E7%B1%BB"><span class="toc-text">十一、内部类和分部类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">1.内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%86%E9%83%A8%E7%B1%BB"><span class="toc-text">2.分部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%88%86%E9%83%A8%E6%96%B9%E6%B3%95"><span class="toc-text">3.分部方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E7%BB%A7%E6%89%BF"><span class="toc-text">知识点二 面向对象三大特性————继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%BB%A7%E6%89%BF%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99"><span class="toc-text">一、继承基本规则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-3"><span class="toc-text">1.基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-2"><span class="toc-text">2.基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AE%9E%E4%BE%8B-2"><span class="toc-text">3.实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%BD%B1%E5%93%8D"><span class="toc-text">4.访问修饰符影响</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%AD%90%E7%B1%BB%E5%92%8C%E7%88%B6%E7%B1%BB%E7%9A%84%E5%90%8C%E5%90%8D%E6%88%90%E5%91%98"><span class="toc-text">5.子类和父类的同名成员</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99"><span class="toc-text">二、里氏替换原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-4"><span class="toc-text">1.基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.基本实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-is%E5%92%8Cas"><span class="toc-text">3.is和as</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">三、继承中的构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-5"><span class="toc-text">1.基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-text">2.继承中构造函数的执行顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%88%B6%E7%B1%BB%E7%9A%84%E6%97%A0%E5%8F%82%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%BE%88%E9%87%8D%E8%A6%81"><span class="toc-text">3.父类的无参构造函数很重要</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%80%9A%E8%BF%87base%E8%B0%83%E7%94%A8%E6%8C%87%E5%AE%9A%E7%88%B6%E7%B1%BB%E6%9E%84%E9%80%A0"><span class="toc-text">4.通过base调用指定父类构造</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E4%B8%87%E7%89%A9%E4%B9%8B%E7%88%B6%E5%92%8C%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1"><span class="toc-text">四、万物之父和装箱拆箱</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%87%E7%89%A9%E4%B9%8B%E7%88%B6"><span class="toc-text">1.万物之父</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%87%E7%89%A9%E4%B9%8B%E7%88%B6%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">2.万物之父的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1"><span class="toc-text">3.装箱拆箱</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%AF%86%E5%B0%81%E7%B1%BB"><span class="toc-text">五、密封类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-6"><span class="toc-text">1.基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%9E%E4%BE%8B"><span class="toc-text">2.实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BD%9C%E7%94%A8"><span class="toc-text">3.作用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E5%A4%9A%E6%80%81"><span class="toc-text">知识点三 面向对象三大特性————多态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%A4%9A%E6%80%81"><span class="toc-text">一、多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%A4%9A%E6%80%81%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">1.多态的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">2.解决的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">3.多态的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E5%87%BD%E6%95%B0"><span class="toc-text">二、抽象类和抽象函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-text">1.抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8A%BD%E8%B1%A1%E5%87%BD%E6%95%B0"><span class="toc-text">2.抽象函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%B3%A8%E6%84%8F"><span class="toc-text">3.注意</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%8E%A5%E5%8F%A3"><span class="toc-text">三、接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">1.接口的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%94%B3%E6%98%8E"><span class="toc-text">2.接口的申明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">3.接口的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%8E%A5%E5%8F%A3%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E6%8E%A5%E5%8F%A3"><span class="toc-text">4.接口可以继承接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%98%BE%E7%A4%BA%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="toc-text">5.显示实现接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%AF%86%E5%B0%81%E6%96%B9%E6%B3%95"><span class="toc-text">四、密封方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AF%86%E5%B0%81%E6%96%B9%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">1.密封方法基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%9E%E4%BE%8B-1"><span class="toc-text">2.实例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-text">知识点四 面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-text">一、命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">1.命名空间的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">2.命名空间的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%8D%E5%90%8C%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9B%B8%E4%BA%92%E4%BD%BF%E7%94%A8%EF%BC%8C%E9%9C%80%E8%A6%81%E5%BC%95%E7%94%A8%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%88%96%E8%80%85%E6%8C%87%E6%98%8E%E5%87%BA%E5%A4%84"><span class="toc-text">3.不同命名空间相互使用，需要引用命名空间或者指明出处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%B8%8D%E5%90%8C%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%B8%AD%E5%85%81%E8%AE%B8%E6%9C%89%E5%90%8C%E5%90%8D%E7%B1%BB"><span class="toc-text">4.不同命名空间中允许有同名类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%8F%AF%E4%BB%A5%E5%8C%85%E8%A3%B9%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-text">5.命名空间可以包裹命名空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%BF%AE%E9%A5%B0%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">6.修饰类的访问修饰符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%B8%87%E7%89%A9%E4%B9%8B%E7%88%B6%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">二、万物之父中的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-object%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">1.object中的静态方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-object%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-text">2.object中的成员方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-object%E4%B8%AD%E7%9A%84%E8%99%9A%E6%96%B9%E6%B3%95"><span class="toc-text">3.object中的虚方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81String"><span class="toc-text">三、String</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E8%8E%B7%E5%8F%96"><span class="toc-text">1.字符串指定位置获取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5"><span class="toc-text">2.字符串拼接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%AD%A3%E5%90%91%E6%9F%A5%E6%89%BE%E5%AD%97%E7%AC%A6%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-text">3.正向查找字符的位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8F%8D%E5%90%91%E6%9F%A5%E6%89%BE%E6%8C%87%E5%AE%9A%E5%AD%97%E7%AC%A6%E4%BD%8D%E7%BD%AE"><span class="toc-text">4.反向查找指定字符位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%A7%BB%E9%99%A4%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E5%90%8E%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="toc-text">5.移除指定位置后的字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%9B%BF%E6%8D%A2%E6%8C%87%E5%AE%9A%E5%AD%97%E7%AC%A6"><span class="toc-text">6.替换指定字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2"><span class="toc-text">7.大小写转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%88%AA%E5%8F%96"><span class="toc-text">8.字符串截取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E5%89%B2%EF%BC%88%E9%9D%9E%E5%B8%B8%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-text">9.字符串切割（非常重要）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-string%E4%B8%8D%E7%AE%A1%E6%98%AF%E9%87%8D%E6%96%B0%E8%B5%8B%E5%80%BC%EF%BC%8C%E8%BF%98%E6%98%AF-%E9%83%BD%E4%BC%9A%E8%A2%AB%E5%88%86%E9%85%8D%E6%96%B0%E7%9A%84%E5%A0%86%E7%A9%BA%E9%97%B4"><span class="toc-text">10.string不管是重新赋值，还是+&#x3D;都会被分配新的堆空间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81StringBuilder"><span class="toc-text">四、StringBuilder</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-7"><span class="toc-text">1.基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%9D%E5%A7%8B%E5%8C%96-%E7%9B%B4%E6%8E%A5%E6%8C%87%E6%98%8E%E5%86%85%E5%AE%B9"><span class="toc-text">2.初始化 直接指明内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AE%B9%E9%87%8F"><span class="toc-text">3.容量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9%E6%9B%BF%E6%8D%A2"><span class="toc-text">4.增删查改替换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E5%86%85%E5%AD%98"><span class="toc-text">5.如何优化内存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">五、结构体和类的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8C%BA%E5%88%AB%E6%A6%82%E8%BF%B0"><span class="toc-text">1.区别概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BB%86%E8%8A%82%E5%8C%BA%E5%88%AB"><span class="toc-text">2.细节区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E7%89%B9%E5%88%AB%E4%B9%8B%E5%A4%84"><span class="toc-text">3.结构体的特别之处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB"><span class="toc-text">4.如何选择结构体和类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">六、抽象类和接口的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%9B%B8%E5%90%8C%E7%82%B9"><span class="toc-text">1.相同点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8C%BA%E5%88%AB"><span class="toc-text">2.区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-text">3.如何选择接口和抽象类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99"><span class="toc-text">七、面向对象七大原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99"><span class="toc-text">1.为什么有七大原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99SRP%EF%BC%88Single-Respondsibility-Principle%EF%BC%89"><span class="toc-text">2.单一职责原则SRP（Single Respondsibility Principle）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99OCP%EF%BC%88Open-Closed-Principle%EF%BC%89"><span class="toc-text">3.开闭原则OCP（Open-Closed Principle）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99LSP%EF%BC%88Liskov-Substitution-Principle%EF%BC%89"><span class="toc-text">4.里氏替换原则LSP（Liskov Substitution Principle）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99DIP%EF%BC%88Dependence-Inversion-Principle%EF%BC%89"><span class="toc-text">5.依赖倒转原则DIP（Dependence Inversion Principle）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%BF%AA%E7%B1%B3%E7%89%B9%E5%8E%9F%E5%88%99LoP%EF%BC%88Law-of-Demeter%EF%BC%89"><span class="toc-text">6.迪米特原则LoP（Law of Demeter）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%8E%A5%E5%8F%A3%E5%88%86%E7%A6%BB%E5%8E%9F%E5%88%99ISP%EF%BC%88Interface-Segregation-Principle%EF%BC%89"><span class="toc-text">7.接口分离原则ISP（Interface Segregation Principle）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99CRP%EF%BC%88Composite-Reuse-Principle%EF%BC%89"><span class="toc-text">8.合成复用原则CRP（Composite Reuse Principle）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E6%80%BB%E7%BB%93"><span class="toc-text">9.总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E8%BF%99%E4%BA%9B%E5%8E%9F%E5%88%99"><span class="toc-text">10.如何使用这些原则</span></a></li></ol></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="知识点一-面向对象三大特性————封装"><a href="#知识点一-面向对象三大特性————封装" class="headerlink" title="知识点一 面向对象三大特性————封装"></a>知识点一 面向对象三大特性————封装</h1><h2 id="一、类和对象"><a href="#一、类和对象" class="headerlink" title="一、类和对象"></a>一、类和对象</h2><h3 id="1-什么是类"><a href="#1-什么是类" class="headerlink" title="1.什么是类"></a>1.什么是类</h3><p>基本概念：</p>
<ul>
<li>具有相同特征</li>
<li>具有相同行为</li>
<li>一类事物的抽象</li>
<li>类是对象的模板</li>
<li>可以通过类创造出对象</li>
<li>类的关键词——class</li>
</ul>
<h3 id="2-类申明在哪里"><a href="#2-类申明在哪里" class="headerlink" title="2.类申明在哪里"></a>2.类申明在哪里</h3><p>namespace命名空间语句块下</p>
<h3 id="3-类申明的语法"><a href="#3-类申明的语法" class="headerlink" title="3.类申明的语法"></a>3.类申明的语法</h3><p>class 类名<br>{<br>    &#x2F;&#x2F;特征——成员变量<br>    &#x2F;&#x2F;行为——成员方法<br>    &#x2F;&#x2F;保护特征——成员属性<br>    &#x2F;&#x2F;构造函数和析构函数<br>    &#x2F;&#x2F;索引器<br>    &#x2F;&#x2F;运算符重载<br>    &#x2F;&#x2F;静态成员<br>}</p>
<h3 id="4-类申明的实例"><a href="#4-类申明的实例" class="headerlink" title="4.类申明的实例"></a>4.类申明的实例</h3><pre><code class="c#">//命名帕斯卡命名法
//同一语句块中的不同类 不能重名
class Person
&#123;

&#125;
</code></pre>
<h3 id="5-什么是类对象"><a href="#5-什么是类对象" class="headerlink" title="5.什么是类对象"></a>5.什么是类对象</h3><p>类的申明和类对象的申明是两个东西<br>类的申明 类似 枚举和结构体的申明 类的申明相当于申明了一个自定义变量类型<br>而对象 是类创造出来的<br>相当于申明一个指定类的变量<br>类创建对象的过程 一般称为实例化对象<br>类对象 都是引用类型</p>
<h3 id="6-实例化对象的基本语法"><a href="#6-实例化对象的基本语法" class="headerlink" title="6.实例化对象的基本语法"></a>6.实例化对象的基本语法</h3><p>类名 变量名;<br>类名 变量名 &#x3D; null;        (null代表空)<br>类名 变量名 &#x3D; new 类名();</p>
<h3 id="7-实例化对象"><a href="#7-实例化对象" class="headerlink" title="7.实例化对象"></a>7.实例化对象</h3><pre><code class="c#">Person p;
Person p2 = null;        //前两个代码相当于在栈上分配一个空间（内存），而在堆上没有分配，为空
Person p3 = new Person();        //栈和堆上都分配了空间，栈一般为地址
</code></pre>
<h2 id="二、成员变量和访问修饰符"><a href="#二、成员变量和访问修饰符" class="headerlink" title="二、成员变量和访问修饰符"></a>二、成员变量和访问修饰符</h2><h3 id="1-成员变量"><a href="#1-成员变量" class="headerlink" title="1.成员变量"></a>1.成员变量</h3><ul>
<li>申明在类语句块中</li>
<li>用来描述对象的特征</li>
<li>可以是任意变量类型</li>
<li>数量不做限制</li>
<li>是否赋值根据需求定<br>例如</li>
</ul>
<pre><code class="c#">class Person
&#123;
    public string name;
    public int age;
    public Person girdFriend;                        //可在类语句块中，定义一个自身名字的变量，会赋值null
    public Person[] friends;                           //禁止对他初始化或实例化，会产生死循环
&#125;
</code></pre>
<h3 id="2-访问修饰符"><a href="#2-访问修饰符" class="headerlink" title="2.访问修饰符"></a>2.访问修饰符</h3><p>public         保护的，自己（内部）和别人（外部）都能访问和使用<br>private        私有的，自己（内部）才能访问使用        不写修饰符，默认为私有的<br>protected        保护的，自己（内部）和子类才能访问和使用</p>
<h3 id="3-成员变量的使用和初始值"><a href="#3-成员变量的使用和初始值" class="headerlink" title="3.成员变量的使用和初始值"></a>3.成员变量的使用和初始值</h3><p>Person p &#x3D; new Person();</p>
<ol>
<li>初始值:        （创建一个类变量时，成员变量都会产生初始的值）</li>
</ol>
<ul>
<li>数字类型默认值为0        </li>
<li>布尔类型初始值为false</li>
<li>引用类型初始值都为空null</li>
</ul>
<pre><code class="c#">//查看初始值的技巧
Console.Write(default(int));
</code></pre>
<ol start="2">
<li>使用</li>
</ol>
<pre><code class="c#">p.name;
</code></pre>
<h2 id="三、成员方法"><a href="#三、成员方法" class="headerlink" title="三、成员方法"></a>三、成员方法</h2><h3 id="1-成员方法申明"><a href="#1-成员方法申明" class="headerlink" title="1.成员方法申明"></a>1.成员方法申明</h3><p>基本概念<br>成员方法（函数）表现对象的行为：</p>
<ul>
<li>申明在类语句块中</li>
<li>是用来描述对象的行为的</li>
<li>规则和函数申明规则相同</li>
<li>受到访问修饰符规则影响</li>
<li>返回值参数不做限制</li>
<li>方法数量不做限制<br>注意：</li>
<li>成员方法不加static关键词</li>
<li>成员方法 必须实例化出对象 在通过对象来使用 相当于对象执行了某个行为</li>
<li>成员方法 受到访问修饰符影响</li>
</ul>
<pre><code class="c#">class Person
&#123;
    public void Speak(string str)
    &#123;
        Console.WriteLine(&quot;&#123;0&#125;说：&#123;1&#125;&quot;, name, str);
    &#125;
    
    public bool isAdult
    &#123;
        return age &gt;= 18;       
    &#125;
    public string name;
    public int age;
&#125;
</code></pre>
<h3 id="2-成员方法的使用"><a href="#2-成员方法的使用" class="headerlink" title="2.成员方法的使用"></a>2.成员方法的使用</h3><pre><code class="c#">Person p = new Person();
p.name = &quot;Link&quot;;
p.age = 18;
p.Speak(&quot;哦&quot;);
</code></pre>
<h2 id="四、构造函数，析构函数和垃圾回收机制"><a href="#四、构造函数，析构函数和垃圾回收机制" class="headerlink" title="四、构造函数，析构函数和垃圾回收机制"></a>四、构造函数，析构函数和垃圾回收机制</h2><h3 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1.构造函数"></a>1.构造函数</h3><p>基本概念：在实例化对象时，会调用的用于初始化的函数。如果不写，默认存在一个无参构造函数。<br>构造函数写法：</p>
<ul>
<li>没有返回值</li>
<li>函数名和类名必须相同</li>
<li>没有特殊需求时，一般都是public的</li>
<li>构造函数可以被重载</li>
<li>this代表当前调用该函数的对象自己<br>注意：<br>如果不自己实现无参构造函数而实现有参构造函数<br>会失去默认的无参构造（即不能再使用无参构造）<br>例子：<br>class Person<br>{<br>  public string name;<br>    public int age;<br>    public Person()                                &#x2F;&#x2F;类中允许自己申明无参构造函数，结构体不允许<br>        {<br>            name &#x3D; “聪哥”;<br>            age &#x3D; 20;<br>        }<br>        public Person(int age, string name)<br>        {<br>            this.age &#x3D; age;<br>            this.name &#x3D; name;                        &#x2F;&#x2F;this代表当前调用该函数的对象自己       <br>        }<br>}</li>
</ul>
<h3 id="2-构造函数特殊写法（可以复用代码）"><a href="#2-构造函数特殊写法（可以复用代码）" class="headerlink" title="2.构造函数特殊写法（可以复用代码）"></a>2.构造函数特殊写法（可以复用代码）</h3><p>可以通过this 重用构造函数代码<br>访问修饰符 构造函数名（参数列表）this（参数1、参数2）<br>例：<br>public Person(int age, string name):this()                &#x2F;&#x2F;this()，指先调用无参的函数<br>{<br>    Console.Write(“”);<br>}</p>
<h3 id="3-析构函数（了解）"><a href="#3-析构函数（了解）" class="headerlink" title="3.析构函数（了解）"></a>3.析构函数（了解）</h3><p>基本概念<br>当引用类型的堆内存被回收时，会调用该函数<br>对于需要手动管理内存的语言（如c++），需要在析构函数中做一些内容的回收处理<br>但是c#存在自动垃圾回收机制GC<br>所以几乎不用使用析构函数。除非你想在某一对象被垃圾回收时，做一些特殊处理<br>注意：<br>在unity开发中析构函数几乎不会使用，做知识点了解即可。<br>基本语法：<br>~类名()<br>{</p>
<p>}</p>
<h3 id="4-垃圾回收机制"><a href="#4-垃圾回收机制" class="headerlink" title="4.垃圾回收机制"></a>4.垃圾回收机制</h3><p>垃圾回收，英文简写GC(Garbage Collector)<br>垃圾回收的过程是在遍历堆(Heap)上动态分配的所有对象<br>通过识别它们是否被引用来确定哪些对象时垃圾，哪些对象仍然要被使用<br>所谓垃圾是没有被任何变量使用，对象引用的内容<br>垃圾就需要被回收释放</p>
<p>垃圾回收有很多算法，比如<br>引用计数（Reference Counting）<br>标记清除（Mark Sweep）<br>标记整理（Mark Compact）<br>复制集合（Copy Collection）</p>
<p>注意：<br>GC只负责堆（Heap）内存的垃圾回收<br>引用类型都是存在堆（Heap）中的，所以它的分配和释放都通过垃圾回收机制来管理<br>栈（Stack）上的内存是由系统自动管理的<br>值类型在栈（Stack）中分配内存时，他们有自己的生命周期，不用对他们进行管理，会自动分配和释放</p>
<p>C#中内存回收机制的大概原理<br>0代内存        1代内存        2代内存<br>代的概念：<br>代是垃圾回收机制使用的一种算法（分代算法）<br>新分配的对象都会被配制在第0代内存中<br>每次分配都可能会进行垃圾回收以释放内存（0代内存满时）</p>
<p>在一次内存回收过程开始时，垃圾回收器会认为堆中全是垃圾，会进行以下两步：</p>
<ul>
<li>标记对象，从根（静态字段，方法参数）开始检查引用对象，标记后为可达对象，未标记为不可达对象，不可达对象就被认为是垃圾。</li>
<li>搬迁对象压缩堆（挂起执行托管代码线程），释放未标记的对象，搬迁可达对象，修改引用地址</li>
</ul>
<p>大对象总被认为是第二代内存，目的是减少性能损耗，提高性能<br>不会对大对象进行搬迁压缩，85000字节（83kb）以上的对象为大对象</p>
<p>手动触发垃圾回收方法：<br>GC.Collect();<br>由于非常消耗性能，一般不会频繁调用<br>在Loading过场时，才调用</p>
<h2 id="五、成员属性"><a href="#五、成员属性" class="headerlink" title="五、成员属性"></a>五、成员属性</h2><h3 id="1-成员属性的基本概念"><a href="#1-成员属性的基本概念" class="headerlink" title="1.成员属性的基本概念"></a>1.成员属性的基本概念</h3><ul>
<li>用于保护成员变量</li>
<li>为成员属性的获取和赋值添加逻辑处理</li>
<li>解决3p属性的局限性<br>注意：属性可以让成员在外部，只能获取不能修改，或只能修改不能获取</li>
</ul>
<h3 id="2-成员属性的基本语法"><a href="#2-成员属性的基本语法" class="headerlink" title="2.成员属性的基本语法"></a>2.成员属性的基本语法</h3><p>访问修饰符 属性类型 属性名<br>{<br>    get{}<br>    set{}<br>}<br>例如</p>
<pre><code class="c#">class Person
&#123;
    private string name;
    private int age;
    private int money;
    private bool sex;
    public string Name
    &#123;
        get
        &#123;
            return name;        //这个属性可以获取的内容，可在返回前添加逻辑规则
        &#125;
        set
        &#123;
            name = value;        //value代表外部传入的值，可在传入前添加逻辑处理
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="3-成员属性的使用"><a href="#3-成员属性的使用" class="headerlink" title="3.成员属性的使用"></a>3.成员属性的使用</h3><pre><code class="c#">Person p = new Person();
p.Name = &quot;聪哥&quot;;                        //实际上执行set语句块
Console.Write(p.Name);             //实际上执行get语句块
</code></pre>
<h3 id="4-成员属性中，get和set可以设置访问修饰符"><a href="#4-成员属性中，get和set可以设置访问修饰符" class="headerlink" title="4.成员属性中，get和set可以设置访问修饰符"></a>4.成员属性中，get和set可以设置访问修饰符</h3><p>注意</p>
<ul>
<li>不加，默认会使用属性申明时的访问权限</li>
<li>加的访问修饰符要低于属性的访问权限</li>
<li>不能让get和set的访问权限都低于属性的权限</li>
</ul>
<h3 id="5-get和set可以只有一个"><a href="#5-get和set可以只有一个" class="headerlink" title="5.get和set可以只有一个"></a>5.get和set可以只有一个</h3><p>注意：<br>只有一个时，没必要在get或set前面加访问修饰符</p>
<h3 id="6-自动属性"><a href="#6-自动属性" class="headerlink" title="6.自动属性"></a>6.自动属性</h3><p>作用：外部能得不能改的特征<br>如果类中有一个特征是只希望外部能得不能改的，又没有什么特殊处理<br>那么可以直接使用自动属性<br>例如</p>
<pre><code class="c#">public float High
&#123;
        get;
        private set;
&#125;
</code></pre>
<h2 id="六、索引器"><a href="#六、索引器" class="headerlink" title="六、索引器"></a>六、索引器</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><p>让对象可以像数组一样通过索引访问其中的元素，使程序看起来更加直观，更容易编写<br>适用于类中有数组类型的成员</p>
<h3 id="2-语法"><a href="#2-语法" class="headerlink" title="2.语法"></a>2.语法</h3><p>访问修饰符 返回值 this[参数类型 参数名, 参数类型 参数名 …… ]<br>{<br>    内部的写法和规则和索引器相同<br>    get{}<br>    set{}<br>}<br>例子</p>
<pre><code class="c#">class Person
&#123;
    private int age;
    private string name;
    private Person[] friends;

    public Person this[int index]
    &#123;
        get
        &#123;
            return friends[index];   
        &#125;
                
        set
        &#123;
            friends[index] = value;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="3-索引器的使用"><a href="#3-索引器的使用" class="headerlink" title="3.索引器的使用"></a>3.索引器的使用</h3><pre><code class="c#">Person p = new Person();
p[0] = new Person();
</code></pre>
<h3 id="4-索引器中可以写逻辑"><a href="#4-索引器中可以写逻辑" class="headerlink" title="4.索引器中可以写逻辑"></a>4.索引器中可以写逻辑</h3><p>与成员属性相似</p>
<h3 id="5-索引器可以重载"><a href="#5-索引器可以重载" class="headerlink" title="5.索引器可以重载"></a>5.索引器可以重载</h3><h2 id="七、静态成员"><a href="#七、静态成员" class="headerlink" title="七、静态成员"></a>七、静态成员</h2><h3 id="1-静态成员的基本概念"><a href="#1-静态成员的基本概念" class="headerlink" title="1.静态成员的基本概念"></a>1.静态成员的基本概念</h3><p>静态关键字 static<br>用 static修饰的 成员变量、方法、属性等<br>称为静态成员<br>特点：直接用类名点出使用</p>
<h3 id="2-早已出现的静态成员变量"><a href="#2-早已出现的静态成员变量" class="headerlink" title="2.早已出现的静态成员变量"></a>2.早已出现的静态成员变量</h3><pre><code class="c#">Console.Write();
</code></pre>
<h3 id="3-自定义静态成员"><a href="#3-自定义静态成员" class="headerlink" title="3.自定义静态成员"></a>3.自定义静态成员</h3><pre><code class="c#">class Test
&#123;
    public static float PI = 3.1415926f;                 //public和static的顺序没有要求
    public int testInt = 100;
    public static float CalcCircle(float r)
    &#123;
        return PI*r*r;
    &#125;
    public void TestFun()
    &#123;
        Console.Write(&quot;666&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="4-静态成员的使用"><a href="#4-静态成员的使用" class="headerlink" title="4.静态成员的使用"></a>4.静态成员的使用</h3><p>使用时</p>
<pre><code class="c#">Console.Write(Test.PI);
Console.Write(Test.CalcCircle(3));
//静态成员不用实例化类就可以直接使用
</code></pre>
<h3 id="5-为什么静态成员可以直接使用"><a href="#5-为什么静态成员可以直接使用" class="headerlink" title="5.为什么静态成员可以直接使用"></a>5.为什么静态成员可以直接使用</h3><p>记住!<br>程序不可能无中生有<br>我们使用的对象、变量和函数都是在内存中分配内存空间的<br>之所以要实例化对象，目的就是要分配内存空间，在程序中产生一个抽象的对象</p>
<p>静态成员的特点<br>程序开始运行时，就会分配内存空间。所以我们能直接使用<br>静态成员和程序同生共死<br>只要使用了它，直到程序结束时才会释放内存空间<br>所以静态成员都有自己唯一的一个“内存小房间”<br>这让静态成员有了唯一性<br>在任何地方使用都是使用小房间内的内容，改变它也是改变小房间的内容</p>
<h3 id="6-静态函数中不能使用非静态成员"><a href="#6-静态函数中不能使用非静态成员" class="headerlink" title="6.静态函数中不能使用非静态成员"></a>6.静态函数中不能使用非静态成员</h3><p>成员变量只能将对象实例化出来后，才能点出来使用，不能无中生有<br>不能直接使用非静态成员，否则会报错<br>若要使用，需要在函数中先实例化对象</p>
<h3 id="7-非静态函数可以使用静态成员"><a href="#7-非静态函数可以使用静态成员" class="headerlink" title="7.非静态函数可以使用静态成员"></a>7.非静态函数可以使用静态成员</h3><h3 id="8-静态成员的作用"><a href="#8-静态成员的作用" class="headerlink" title="8.静态成员的作用"></a>8.静态成员的作用</h3><ol>
<li>常用唯一变量的申明</li>
<li>方便别人获取的对象申明</li>
<li>静态方法：常用的唯一的方法申明，比如，相同规则的数学计算相关函数</li>
</ol>
<h3 id="9-常量和静态变量"><a href="#9-常量和静态变量" class="headerlink" title="9.常量和静态变量"></a>9.常量和静态变量</h3><p>const常量 可以理解为特殊的静态<br>相同点：<br>他们都可以通过类名点出使用<br>不同点：<br>a.const必须初始化，不能修改，static没有这个规则<br>b.const只能修饰变量，static可以修饰很多种<br>c.const一定是写在访问修饰符后面，static没有这个要求</p>
<h2 id="八、静态类和静态构造函数"><a href="#八、静态类和静态构造函数" class="headerlink" title="八、静态类和静态构造函数"></a>八、静态类和静态构造函数</h2><h3 id="1-静态类"><a href="#1-静态类" class="headerlink" title="1.静态类"></a>1.静态类</h3><p>概念：<br>用static修饰的类<br>特点：<br>只能包含静态函数<br>不能被实例化<br>作用：</p>
<ul>
<li>将常用的静态成员，写在静态类中，方便使用</li>
<li>静态类不能被实例化，更能体现工具类的唯一性<br>比如，Console就是一个静态类</li>
</ul>
<p>例如</p>
<pre><code class="c#">static class TestStatic
&#123;
    public static int testLine = 10;
    public static void testFun()
    &#123;
                
    &#125;

    public static int TestLine
    &#123;
        get
        &#123;
            return testLine;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="2-静态构造函数（少用）"><a href="#2-静态构造函数（少用）" class="headerlink" title="2.静态构造函数（少用）"></a>2.静态构造函数（少用）</h3><p>概念：<br>在构造函数前加一个static修饰<br>特点：</p>
<ul>
<li>静态类和普通类都可以有</li>
<li>不能使用访问修饰符</li>
<li>不能有参数</li>
<li>第一次使用静态类中的成员时，静态构造函数就会先自动调用</li>
<li>只会调用一次</li>
<li>普通类中的静态构造函数，也只会在第一次使用时调用<br>作用：<br>在静态构造函数中初始化静态变量<br>使用：</li>
</ul>
<ol>
<li>静态类中的静态构造函数</li>
</ol>
<pre><code class="c#">static class StaticClass
&#123;
    public static int testInt = 100;
    public static int testInt2 = 200; 

    static StaticClass()
    &#123;
        Console.WriteLine(&quot;&quot;);
    &#125;
&#125;
</code></pre>
<ol start="2">
<li>普通类中的静态构造函数</li>
</ol>
<pre><code class="c#">Class Test
&#123;
    public static int intIndex = 200;
        
    static Test()
    &#123;
        Console.Write(&quot;静态&quot;);
    &#125;

    public Test()                //普通和静态互不干扰，不算重载
    &#123;
        Console.Write(&quot;普通&quot;);  
    &#125;
&#125;
</code></pre>
<h2 id="九、拓展方法"><a href="#九、拓展方法" class="headerlink" title="九、拓展方法"></a>九、拓展方法</h2><h3 id="1-基本概念-1"><a href="#1-基本概念-1" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><p>概念：<br>为现有非静态类 变量类型 添加新方法<br>作用：</p>
<ul>
<li>提升程序的拓展性</li>
<li>不需要在对象中重新写方法</li>
<li>不需要继承来添加方法</li>
<li>为别人封装的类型写额外的方法</li>
</ul>
<p>特点：</p>
<ul>
<li>一定是写在静态类中</li>
<li>一定是静态函数</li>
<li>第一个参数为拓展目标</li>
<li>第一个参数用this修饰</li>
</ul>
<h3 id="2-基本语法"><a href="#2-基本语法" class="headerlink" title="2.基本语法"></a>2.基本语法</h3><p>访问修饰符 static 返回值 函数名(this 拓展类名 参数名, 参数类型 参数名, 参数类型 参数名…)</p>
<h3 id="3-实例"><a href="#3-实例" class="headerlink" title="3.实例"></a>3.实例</h3><pre><code class="c#">static class Tools
&#123;
    //相当于为int拓展一个成员方法
    //成员方法需要先实例化对象后才能使用
    //value 代表 使用该方法的 实例化对象
    public static void SpeakValue(this int value)
    &#123;
        Console.Write(&quot;你好世界！&quot; + value);
    &#125;
&#125;
</code></pre>
<h3 id="4-使用"><a href="#4-使用" class="headerlink" title="4.使用"></a>4.使用</h3><pre><code class="c#">int i = 10;
i.SpeakValue();
</code></pre>
<h3 id="5-为自定义类型拓展方法"><a href="#5-为自定义类型拓展方法" class="headerlink" title="5.为自定义类型拓展方法"></a>5.为自定义类型拓展方法</h3><p>与上面相同，但若拓展方法的方法名与自定义类中的成员方法名相同，不会报错，但调用时只会调用成员方法。</p>
<h2 id="十、运算符重载"><a href="#十、运算符重载" class="headerlink" title="十、运算符重载"></a>十、运算符重载</h2><h3 id="1-基本概念-2"><a href="#1-基本概念-2" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><p>让自定义类和结构体 能够使用运算符<br>使用关键字：operator<br>特点：</p>
<ul>
<li>一定是一个公共的静态方法</li>
<li>返回值写在operator前</li>
<li>逻辑处理自定义<br>作用：<br>让自定义类和结构体对象可以进行运算<br>注意：</li>
<li>条件运算符需要成对实现</li>
<li>一个符号可以多个重载</li>
<li>不能使用ref和out</li>
</ul>
<h3 id="2-基本语法-1"><a href="#2-基本语法-1" class="headerlink" title="2.基本语法"></a>2.基本语法</h3><p>public static 返回类型 operator 运算符(参数列表)<br>参数列表最多写两个</p>
<h3 id="3-实例-1"><a href="#3-实例-1" class="headerlink" title="3.实例"></a>3.实例</h3><pre><code class="c#">class Point
&#123;
    public int x;
    public int y;

    public static Point operator +(Point p1, Point p2)
    &#123;
        Point p = new Point():
        p.x = p1.x + p2.x;
        p.y = p1.y + p2.y;
        return p;
    &#125;
&#125;
</code></pre>
<h3 id="4-使用-1"><a href="#4-使用-1" class="headerlink" title="4.使用"></a>4.使用</h3><pre><code class="c#">Point p1 = new Point();
p1.x = 2;
p1.y = 2;
Point p2 = new Point();
p2.x = 3;
p2.y = 3;
Point p3 = p1 + p2;
</code></pre>
<h3 id="5-可重载和不可重载的运算符"><a href="#5-可重载和不可重载的运算符" class="headerlink" title="5.可重载和不可重载的运算符"></a>5.可重载和不可重载的运算符</h3><p>可重载的运算符：</p>
<ul>
<li>算数运算符：- 、* 、&#x2F; 、% 、++ 、– </li>
<li>逻辑运算符：!</li>
<li>位运算符：|、&amp;、~、^、&lt;&lt;、&gt;&gt;</li>
<li>条件运算法：&gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;、&#x3D;&#x3D;、!&#x3D;        &#x2F;&#x2F;必须成对实现，比如有 &gt; 就必须有 &lt;，返回值一般为bool值<br>不可重载的运算符：</li>
<li>逻辑与(&amp;&amp;)和逻辑或(||)</li>
<li>索引符号（[ ]）</li>
<li>强转运算符()</li>
<li>特殊运算符</li>
<li>点.        </li>
<li>三目运算符? :        </li>
<li>赋值符号 &#x3D;</li>
</ul>
<p> </p>
<h2 id="十一、内部类和分部类"><a href="#十一、内部类和分部类" class="headerlink" title="十一、内部类和分部类"></a>十一、内部类和分部类</h2><h3 id="1-内部类"><a href="#1-内部类" class="headerlink" title="1.内部类"></a>1.内部类</h3><p>概念：<br>在一个类中再申明一个类<br>特点：<br>使用时要用包裹者点出自己<br>作用：<br>亲密关系的表现<br>注意：<br>访问修饰符作用很大<br>实例：</p>
<pre><code class="c#">class Person
&#123;
    public int age;
    public string name;
    public Body body;
    public class Body
    &#123;
        Arm rightarm;
        Arm leftarm;
        class Arm
        &#123;

        &#125;
    &#125;
&#125;
//使用时
Person p = new Person();
Person.Body body = new Person.Body();
</code></pre>
<h3 id="2-分部类"><a href="#2-分部类" class="headerlink" title="2.分部类"></a>2.分部类</h3><p>概念：<br>把一个类分成几部分声明<br>关键字：   partial<br>作用：<br>分部描述一个类，增加程序拓展性<br>注意：<br>分部类可以写在多个脚本文件中<br>分部类的访问修饰符要求一致<br>分部类中不能有重复成员<br>实例：</p>
<pre><code class="c#">partial class Student
&#123;
    public bool sex;
    public string name;
&#125;
partial class Student
&#123;
    public int number;
&#125;
</code></pre>
<h3 id="3-分部方法"><a href="#3-分部方法" class="headerlink" title="3.分部方法"></a>3.分部方法</h3><p>概念<br>将方法的申明和实现分离<br>特点<br>a.不能加方法修饰符，默认私有<br>b.只能在分部类中申明<br>c.返回值只能是void<br>d.可以有参数但不能用关键字out<br>实例</p>
<pre><code class="c#">partial class Student
&#123;
    public bool sex;
    public string name;
    partial void Speak();
&#125;
partial class Student
&#123;
    public int number;
    partial void Speak()
    &#123;
        //实现方法
    &#125;
&#125;
</code></pre>
<h1 id="知识点二-面向对象三大特性————继承"><a href="#知识点二-面向对象三大特性————继承" class="headerlink" title="知识点二 面向对象三大特性————继承"></a>知识点二 面向对象三大特性————继承</h1><h2 id="一、继承基本规则"><a href="#一、继承基本规则" class="headerlink" title="一、继承基本规则"></a>一、继承基本规则</h2><h3 id="1-基本概念-3"><a href="#1-基本概念-3" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><p>一个类A继承一个类B<br>类A将会继承类B的所有成员<br>A类将拥有B类的所有特征和行为<br>被继承的类称为父类、基类、超类<br>继承的类称为子类、派生类<br>子类可以有自己的特征和行为<br>特点：</p>
<ul>
<li>单根性，子类只能有一个父类</li>
<li>传递性，子类可以间接继承父类的父类</li>
</ul>
<h3 id="2-基本语法-2"><a href="#2-基本语法-2" class="headerlink" title="2.基本语法"></a>2.基本语法</h3><p>class 类名 : 被继承的类名<br>{</p>
<p>}</p>
<h3 id="3-实例-2"><a href="#3-实例-2" class="headerlink" title="3.实例"></a>3.实例</h3><pre><code class="c#">class Teacher
&#123;
    public string name;
    public int number;
    public void Speak()
    &#123;
        Console.WriteLine(name);
    &#125;
&#125;
class TeachingTeacher : Teacher
&#123;
    public string subject:
    public void SpeakSubject()
    &#123;
        Console.Write(subject + &quot;老师&quot;);
    &#125;
&#125;
//使用时：
TeachingTeacher tt = new TeachingTeacher();
tt.name = &quot;聪儿老师&quot;;
tt.subject = &quot;Unity&quot;;
</code></pre>
<h3 id="4-访问修饰符影响"><a href="#4-访问修饰符影响" class="headerlink" title="4.访问修饰符影响"></a>4.访问修饰符影响</h3><p>public                公共的<br>private                私有的，仅仅在内部能使用，子类中不能使用<br>protected             保护的，在内部和子类中可以使用</p>
<h3 id="5-子类和父类的同名成员"><a href="#5-子类和父类的同名成员" class="headerlink" title="5.子类和父类的同名成员"></a>5.子类和父类的同名成员</h3><p>c#中允许子类存在和父类同名的成员，但不建议使用<br>public new string name;        &#x2F;&#x2F;表示直接将父类的name覆盖了<br>若不加new也会覆盖，在外部使用时只会使用子类的name</p>
<h2 id="二、里氏替换原则"><a href="#二、里氏替换原则" class="headerlink" title="二、里氏替换原则"></a>二、里氏替换原则</h2><h3 id="1-基本概念-4"><a href="#1-基本概念-4" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><p>里氏替换原则是面向对象七大原则中最重要的原则<br>概念：<br>任何父类出现的地方，子类都可以替代<br>重点：<br>语法表现，父类容器装子类对象，因为子类对象包含了父类的所有内容<br>作用：<br>方便进行对象存储和管理</p>
<h3 id="2-基本实现"><a href="#2-基本实现" class="headerlink" title="2.基本实现"></a>2.基本实现</h3><pre><code class="c#">class GameObject
&#123;

&#125;

class Player : GameObject
&#123;
    public void PlayerAtk()
    &#123;
        Console.WriteLine(&quot;玩家攻击&quot;);
    &#125;
&#125;

class Monster : GameObject
&#123;
    public void MonsterAtk()
    &#123;
        Console.WriteLine(&quot;怪物攻击&quot;);
    &#125;
&#125;

class Boss : GameObject
&#123;
    public void BossAtk()
    &#123;
        Console.WriteLine(&quot;波斯攻击&quot;);
    &#125;
&#125;
//使用时：
GameObject player = new Player();        //用父类容器装载子类对象
</code></pre>
<h3 id="3-is和as"><a href="#3-is和as" class="headerlink" title="3.is和as"></a>3.is和as</h3><p>基本概念：<br>is：判断一个对象是否是指定的类对象<br>返回值：bool        是为真，不是为假<br>as：将一个对象转换为指定类对象<br>返回值：指定类型对象<br>成功返回指定的类型对象，失败返回null<br>基本语法：<br>类对象 is 类名        该语句块 会有一个bool返回值 true和false<br>类对象 as 类名        该语句块 会有一个对象返回值 对象和null<br>实例：</p>
<pre><code class="c#">if( player is Player)
&#123;
        (player as Player).PlayerAtk();
&#125;
</code></pre>
<h2 id="三、继承中的构造函数"><a href="#三、继承中的构造函数" class="headerlink" title="三、继承中的构造函数"></a>三、继承中的构造函数</h2><h3 id="1-基本概念-5"><a href="#1-基本概念-5" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><p>特点<br>当申明一个子类对象时<br>先执行父类的构造函数<br>再执行子类的构造函数<br>注意<br>父类的无参构造很重要<br>子类可以通过base关键字，代表父类，调用父类构造函数</p>
<h3 id="2-继承中构造函数的执行顺序"><a href="#2-继承中构造函数的执行顺序" class="headerlink" title="2.继承中构造函数的执行顺序"></a>2.继承中构造函数的执行顺序</h3><p>父类的父类的构造函数  ——&gt;  父类的构造函数  ——&gt;  子类的构造函数</p>
<h3 id="3-父类的无参构造函数很重要"><a href="#3-父类的无参构造函数很重要" class="headerlink" title="3.父类的无参构造函数很重要"></a>3.父类的无参构造函数很重要</h3><p>子类实例化时，会默认调用父类的无参构造函数<br>若父类无参构造函数被顶掉，则实例化子类时，子类无法执行父类的无参构造函数，会报错</p>
<h3 id="4-通过base调用指定父类构造"><a href="#4-通过base调用指定父类构造" class="headerlink" title="4.通过base调用指定父类构造"></a>4.通过base调用指定父类构造</h3><pre><code class="c#">class Father
&#123;
    public Father( int i )
    &#123;

    &#125;
&#125;
class Son : Father
&#123;
    //base表示父类
    public Son() : base(i)        
    &#123;
                
    &#125;
        
    public Son(int i ) : this()
    &#123;

    &#125;
&#125;
</code></pre>
<h2 id="四、万物之父和装箱拆箱"><a href="#四、万物之父和装箱拆箱" class="headerlink" title="四、万物之父和装箱拆箱"></a>四、万物之父和装箱拆箱</h2><h3 id="1-万物之父"><a href="#1-万物之父" class="headerlink" title="1.万物之父"></a>1.万物之父</h3><p>关键字：object<br>概念：<br>object是所有类型的基类，他是一个类（引用类型）<br>作用：</p>
<ul>
<li>可以利用里氏替换原则，用object容器装所有对象</li>
<li>可以用来表示不确定类型，作为函数参数类型</li>
</ul>
<h3 id="2-万物之父的使用"><a href="#2-万物之父的使用" class="headerlink" title="2.万物之父的使用"></a>2.万物之父的使用</h3><p>引用类型：</p>
<pre><code class="c#">object o = new Son();        //object可以装载所有类型的对象
用 is 和 as 来判断和转换即可
if( o is Son )
&#123;
        (o is Son).Speak();
&#125;
</code></pre>
<p>值类型：</p>
<pre><code class="c#">object o2 = 1;
用强转
int i = (int)o2;
</code></pre>
<p>string类型</p>
<pre><code class="c#">object str = &quot;123&quot;;
string str2 = str.ToString();
string str2 = str as string;
object arr = new int[10];
int[] arr2 = arr as int[];
int[] arr2 = (int[])arr;
</code></pre>
<h3 id="3-装箱拆箱"><a href="#3-装箱拆箱" class="headerlink" title="3.装箱拆箱"></a>3.装箱拆箱</h3><p>发生条件<br>用object存值类型（装箱）<br>再把object转为值类型（拆箱）</p>
<p>装箱<br>把值类型用引用类型存储<br>栈内存会迁移到堆内存中</p>
<p>拆箱<br>把引用类型存储的值类型取出来<br>堆内存会迁移到栈内存中</p>
<p>好处：不确定类型时，可以方便参数的存储和传递<br>坏处：存在内存迁移时，增加性能损耗</p>
<p>例如</p>
<pre><code class="c#">object v = 3;                //装箱
int intValue = (int)v;        //拆箱

static void Test( params object[] away)                //可以传入任何类型的参数
&#123;

&#125;
</code></pre>
<h2 id="五、密封类"><a href="#五、密封类" class="headerlink" title="五、密封类"></a>五、密封类</h2><h3 id="1-基本概念-6"><a href="#1-基本概念-6" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><p>使用sealed密封关键字修饰的类<br>作用：让类无法再被继承</p>
<h3 id="2-实例"><a href="#2-实例" class="headerlink" title="2.实例"></a>2.实例</h3><p>sealed class Father<br>{</p>
<p>}</p>
<h3 id="3-作用"><a href="#3-作用" class="headerlink" title="3.作用"></a>3.作用</h3><p>在面向对象程序的设计中，密封类的主要作用就是不允许最底层子类被继承<br>可以保证程序的规范性、安全性</p>
<h1 id="知识点三-面向对象三大特性————多态"><a href="#知识点三-面向对象三大特性————多态" class="headerlink" title="知识点三 面向对象三大特性————多态"></a>知识点三 面向对象三大特性————多态</h1><h2 id="一、多态"><a href="#一、多态" class="headerlink" title="一、多态"></a>一、多态</h2><h3 id="1-多态的概念"><a href="#1-多态的概念" class="headerlink" title="1.多态的概念"></a>1.多态的概念</h3><p>多态按字面意思就是“多种状态”<br>让继承同一父类的子类们，在执行相同方法时有不同的表现（状态）<br>主要目的：<br>同一父类的对象，执行相同行为（方法）有不同的表现<br>解决的问题：<br>让同一对象有唯一行为的特征</p>
<h3 id="2-解决的问题"><a href="#2-解决的问题" class="headerlink" title="2.解决的问题"></a>2.解决的问题</h3><pre><code class="c#">class Father
&#123;
    public void Speak()
    &#123;
        Console.WriteLine(&quot;Father的方法&quot;);
    &#125;
&#125;
class Son
&#123;
    public void Speak()
    &#123;
        Console.WriteLine(&quot;Son的方法&quot;);
    &#125;
&#125;
//使用时：
Father f = new Son();
f.Speak();                                //此时调用的是父类的方法
(f as Son).Speak();                //此时调用的是子类的方法
</code></pre>
<p>多态就是解决这种不是唯一性的问题</p>
<h3 id="3-多态的实现"><a href="#3-多态的实现" class="headerlink" title="3.多态的实现"></a>3.多态的实现</h3><p>我们目前已学过的多态<br>编译时的多态——函数重载，开始就写好的<br>我们将学习的：<br>运行时的多态（vob、抽象函数、接口）<br>我们今天学习 vob<br>v：virtual(虚函数)<br>o：override（重写）<br>b：base（父类）<br>实例：</p>
<pre><code class="c#">class GameObject
&#123;
    public string name;
    public virtual GameObject(string name)
    &#123;
        this.name = name;
    &#125;
    public void Atk()
    &#123;
        Console.WriteLine(&quot;游戏对象进行了攻击&quot;);
    &#125;
&#125;
class Player : GameObject
&#123;
    public Player(string name) : base(name)
    &#123;
                
    &#125;
    public override  void Atk()
    &#123;
        base.Atk();                //调用父类的方法
        Console.WriteLine(&quot;玩家进行了攻击&quot;);
    &#125;
&#125;
//使用时:
GameObject g = new Player(&quot;聪&quot;);
g.Atk();        //这时会调用Player类的方法
</code></pre>
<h2 id="二、抽象类和抽象函数"><a href="#二、抽象类和抽象函数" class="headerlink" title="二、抽象类和抽象函数"></a>二、抽象类和抽象函数</h2><h3 id="1-抽象类"><a href="#1-抽象类" class="headerlink" title="1.抽象类"></a>1.抽象类</h3><p>概念：<br>被抽象关键字abstract修饰的类<br>特点：</p>
<ul>
<li>不能被实例化的类，但可遵循里氏替换原则</li>
<li>可以包含抽象方法</li>
<li>继承抽象类必须重写其抽象方法<br>实例：</li>
</ul>
<pre><code class="c#">abstract class Thing
&#123;
    public string name;                //抽象类中，封装的所有知识点都可以在其中书写
        //可以在抽象类中写抽象函数
&#125;
</code></pre>
<h3 id="2-抽象函数"><a href="#2-抽象函数" class="headerlink" title="2.抽象函数"></a>2.抽象函数</h3><p>又叫纯虚方法<br>用 abstract 关键字修饰的方法<br>特点：</p>
<ul>
<li>只能在抽象类中申明</li>
<li>没有方法体</li>
<li>不能是私有的</li>
<li>继承后必须实现 用override重写<br>例如：</li>
</ul>
<pre><code class="c#">abstract class Fruits
&#123;
    public string name;
    public abstract void Bad();                //抽象方法没有方法体，不用实现
&#125;
class Apple : Fruits                                //点小灯泡即可快速写出方法
&#123;
    public override void Bad()                //必须实现抽象父类中的抽象方法，否则报错
    &#123;          //虚方法子类可以选择性实现，抽象方法必须实现
                //子类的子类可以选择是否实现抽象方法
    &#125;
&#125;
</code></pre>
<h3 id="3-注意"><a href="#3-注意" class="headerlink" title="3.注意"></a>3.注意</h3><p>如何选择普通类还是抽象类？<br>不希望被实例化的对象，相对比较抽象的类可以使用抽象类<br>父类中的行为不太需要被实现的，只希望子类去定义具体规则的，可以选择抽象类，然后使用其中的抽象方法来定义规则</p>
<h2 id="三、接口"><a href="#三、接口" class="headerlink" title="三、接口"></a>三、接口</h2><h3 id="1-接口的概念"><a href="#1-接口的概念" class="headerlink" title="1.接口的概念"></a>1.接口的概念</h3><p>接口是行为的抽象规范<br>它也是一种自定义类型<br>关键字：interface</p>
<p>接口申明的规范</p>
<ul>
<li>不包含成员变量</li>
<li>只包含方法、属性、索引器、事件</li>
<li>成员不能被实现</li>
<li>成员可以不用写访问修饰符，不能是私有的</li>
<li>接口不能继承类，但是可以继承另一个接口</li>
</ul>
<p>接口的使用规范</p>
<ul>
<li>类可以继承多个接口</li>
<li>类继承接口后，必须实现接口中的所有成员</li>
</ul>
<p>特点：</p>
<ul>
<li>它和类的申明是类似的</li>
<li>接口是用来继承的</li>
<li>接口不能被实例化，但是可以作为容器存储对象</li>
</ul>
<h3 id="2-接口的申明"><a href="#2-接口的申明" class="headerlink" title="2.接口的申明"></a>2.接口的申明</h3><p>接口关键字：interface<br>语法：<br>interface 接口名<br>{</p>
<p>}<br>一句话记忆：接口是抽象行为的基类<br>接口命名规范：帕斯卡前加个大写i<br>申明：</p>
<pre><code class="c#">interface IFly
&#123;
    void Fly();        //可以不加访问修饰符，不加默认为public，但不能为private
    string Name        //可以写成员属性，但get和set不能写语句块
    &#123;
        get;        
        set;
    &#125;

    int this[int index]        //索引器也一样
    &#123;
        get;
        set;
    &#125;
&#125;
</code></pre>
<h3 id="3-接口的使用"><a href="#3-接口的使用" class="headerlink" title="3.接口的使用"></a>3.接口的使用</h3><p>接口是用来继承的</p>
<pre><code class="c#">class Animal
&#123;

&#125;
class Person : Animal, IFly
&#123;
    public void Fly()                //可以在实现的接口函数前加virtual，再在子类重写
    &#123;

    &#125;      
    public string Name       
    &#123;
        get;        
        set;
    &#125;

    public int this[int index]       
    &#123;
        get;
        set;
    &#125;
&#125;
</code></pre>
<p>注意：</p>
<ul>
<li>类可以继承一个类，n个接口</li>
<li>继承了接口之后，必须实现其中的内容，并且必须是public的</li>
<li>可以在实现的接口函数前加virtual，再在子类重写</li>
<li>接口也遵循里氏替换原则<br>比如在使用时：<br>IFly p &#x3D; new Person();        &#x2F;&#x2F;可以</li>
</ul>
<h3 id="4-接口可以继承接口"><a href="#4-接口可以继承接口" class="headerlink" title="4.接口可以继承接口"></a>4.接口可以继承接口</h3><p>接口继承接口时，不需要实现<br>待类继承接口时，类去实现所有内容</p>
<h3 id="5-显示实现接口"><a href="#5-显示实现接口" class="headerlink" title="5.显示实现接口"></a>5.显示实现接口</h3><p>当一个类继承两个接口时<br>但是接口中存在同名方法时<br>注意：显示实现接口时，不能添加访问修饰符<br>例如：</p>
<pre><code class="c#">interface IAtk
&#123;
    void Atk();
&#125;
interface ISuperAtk
&#123;
    void Atk():
&#125;
class Player : IAtk, ISuperAtk
&#123;
    void IAtk.Atk()                //显示实现接口就是用  接口名.行为名  实现它
    &#123;

    &#125;
    void ISuperAtk.Atk()
    &#123;

    &#125;        
&#125;
//使用时：
Player p = new Player();
(p as IAtk).Atk();                //使用时只能转成对应接口来使用
</code></pre>
<h2 id="四、密封方法"><a href="#四、密封方法" class="headerlink" title="四、密封方法"></a>四、密封方法</h2><h3 id="1-密封方法基本概念"><a href="#1-密封方法基本概念" class="headerlink" title="1.密封方法基本概念"></a>1.密封方法基本概念</h3><p>用密封关键字sealed 修饰的重写函数<br>作用：让虚方法或者抽象方法之后不能再重写<br>特点：和override一起出现</p>
<h3 id="2-实例-1"><a href="#2-实例-1" class="headerlink" title="2.实例"></a>2.实例</h3><pre><code class="c#">abstract class Animal
&#123;
    public string name;
    public abstract void Eat();   
&#125;
class Person : Animal
&#123;
    public sealed override void Eat()                    //这个方法密封了，之后的子类就不能对它重写
    &#123;

    &#125;
&#125;
</code></pre>
<h1 id="知识点四-面向对象"><a href="#知识点四-面向对象" class="headerlink" title="知识点四 面向对象"></a>知识点四 面向对象</h1><h2 id="一、命名空间"><a href="#一、命名空间" class="headerlink" title="一、命名空间"></a>一、命名空间</h2><h3 id="1-命名空间的基本概念"><a href="#1-命名空间的基本概念" class="headerlink" title="1.命名空间的基本概念"></a>1.命名空间的基本概念</h3><p>概念：<br>命名空间是用来组织和重用代码的<br>作用：<br>就像是一个工具包，类就像是一件一件的工具，都是申明在命名空间中的</p>
<h3 id="2-命名空间的使用"><a href="#2-命名空间的使用" class="headerlink" title="2.命名空间的使用"></a>2.命名空间的使用</h3><p>基本语法<br>namespace 命名空间名<br>{<br>    类<br>    类<br>}<br>实例</p>
<pre><code class="c#">namespace MyGame                                //命名空间可以同名，都是同一命名空间
&#123;
        class GameObject
        &#123;

        &#125;
&#125;
namespace MyGame
&#123;
        class Player : MyGame
        &#123;

        &#125;
&#125;
</code></pre>
<h3 id="3-不同命名空间相互使用，需要引用命名空间或者指明出处"><a href="#3-不同命名空间相互使用，需要引用命名空间或者指明出处" class="headerlink" title="3.不同命名空间相互使用，需要引用命名空间或者指明出处"></a>3.不同命名空间相互使用，需要引用命名空间或者指明出处</h3><pre><code class="c#">using MyGame                                                        //using写在代码开头
class Job
&#123;
        GameObject g = new GameObject();                //使用不同命名空间的成员，需要先用using
&#125;
//或者
MyGame.GameObject g = new MyGame.GameObject();        //此时不用using
</code></pre>
<h3 id="4-不同命名空间中允许有同名类"><a href="#4-不同命名空间中允许有同名类" class="headerlink" title="4.不同命名空间中允许有同名类"></a>4.不同命名空间中允许有同名类</h3><p>若有同名类，则必须使用 命名空间名.类名  ，否则会报错</p>
<h3 id="5-命名空间可以包裹命名空间"><a href="#5-命名空间可以包裹命名空间" class="headerlink" title="5.命名空间可以包裹命名空间"></a>5.命名空间可以包裹命名空间</h3><p>例如</p>
<pre><code class="c#">namespace MyGame
&#123;
        namespace UI                        //工具包中的小包
        &#123;
                class Image
                &#123;

                &#125;
        &#125;
       
        namespace Game
        &#123;
                class Image
                &#123;

                &#125;
        &#125;
&#125;
//使用时
MyGame.UI.Image I = new MyGame.UI.Image();
MyGame.Game.Image I2 = new MyGame.Game.Image();
//或者 在引用时     
using MyGame.UI;        
//单引用MyGame是不能用UI中的成员
</code></pre>
<h3 id="6-修饰类的访问修饰符"><a href="#6-修饰类的访问修饰符" class="headerlink" title="6.修饰类的访问修饰符"></a>6.修饰类的访问修饰符</h3><ul>
<li>public————公开的</li>
<li>internal————只能在该程序集（该工程）中使用，命名空间中的类，默认为public</li>
<li>abstract————抽象类</li>
<li>sealed————密封类</li>
<li>partial————分布类</li>
</ul>
<h2 id="二、万物之父中的方法"><a href="#二、万物之父中的方法" class="headerlink" title="二、万物之父中的方法"></a>二、万物之父中的方法</h2><h3 id="1-object中的静态方法"><a href="#1-object中的静态方法" class="headerlink" title="1.object中的静态方法"></a>1.object中的静态方法</h3><ol>
<li>静态方法 Equals<br>判断两个对象是否相等<br>最终的判断权，交给左侧对象的Equals方法<br>不管值类型引用类型都会按照左侧对象Equals方法（指的是虚方法Equals）的规则进行比较<br>实例</li>
</ol>
<pre><code class="c#">Console.Write(object.Equals(1, 1));        //打印出true
class Test
&#123;

&#125;
Test t = new Test();
Test t2 = new Test();
Console.Write(object.Equals(t, t2));        //打印出false，因为t和t2指向的不是同一个房间
</code></pre>
<ol start="2">
<li>静态方法ReferenceEquals<br>比较两个对象是否是相同的引用，主要是用来比较引用类型的对象<br>值类型对象返回值始终是false</li>
</ol>
<pre><code class="c#">Console.Write(object.ReferenceEquals(1, 1));        //返回false
Console.Write(object.ReferenceEquals(t, t2));         //返回false
//&quot;object.&quot;可以省略
</code></pre>
<h3 id="2-object中的成员方法"><a href="#2-object中的成员方法" class="headerlink" title="2.object中的成员方法"></a>2.object中的成员方法</h3><ol>
<li><p>普通方法GetType<br>该方法在反射知识点中非常重要<br>主要作用就是获取对象对象运行时的类型Type<br>通过Type结合反射相关知识点可以做很多关于对象的操作</p>
</li>
<li><p>普通方法MemberwiseClone<br>该方法用于获取对象的浅拷贝对象，口语化意思就是会返回一个新的对象<br>但是新对象中的引用变量和老对象中一致（理解为没有拷贝干净，引用类型还是指向一个房间）<br>例如</p>
</li>
</ol>
<pre><code class="c#">class Test
&#123;
    public int i = 1;
    public Test2 t2 = new Test2();
    public Test Clone()
    &#123;
        return MemberwiseClone() as Test; 
        //MemberwiseClone是保护类型的方法，外部无法使用
    &#125;
&#125;
class Test2
&#123;
    public int i = 2;
&#125;
//使用时：
Test t = new Test();
Test t2 = t.Clone();
//若改变 t2.t2.i，则 t.t2.i 也会改变
//但改变 t2.i，则 t.i 不会改变
//i是值类型
</code></pre>
<h3 id="3-object中的虚方法"><a href="#3-object中的虚方法" class="headerlink" title="3.object中的虚方法"></a>3.object中的虚方法</h3><ol>
<li>虚方法Equals<br>默认实现还是比较两者是否为同一个引用，即相当于ReferenceEquals<br>但是微软在所有值类型的基类System.ValueType中重写了该方法，用来比较值相等<br>我们也可以重写该方法，定义自己的比较相等的规则</li>
<li>虚方法GetHashCode<br>该方法是获取对象的哈希码<br>哈希码是一种通过算法算出的，表示对象的唯一编码，不同对象哈希码有可能相同，具体根据哈希算法决定<br>我们可以通过重写该函数来定义自己对象的哈希码算法，正常情况下，使用极少，基本不用</li>
<li>虚方法ToString<br>该方法用于返回当前对象代表的字符串，我们可以重写它来定义我们自己对象的转字符串规则<br>该方法非常常用，当我们调用打印方法时，默认使用的就是对象的ToString方法后打印出来的结果</li>
</ol>
<h2 id="三、String"><a href="#三、String" class="headerlink" title="三、String"></a>三、String</h2><h3 id="1-字符串指定位置获取"><a href="#1-字符串指定位置获取" class="headerlink" title="1.字符串指定位置获取"></a>1.字符串指定位置获取</h3><p>字符串本质是char数组</p>
<pre><code class="c#">string str = &quot;林克&quot;;
Console.Write(str[0]);
//转为char数组
char[] chars = str.TocharArray();
</code></pre>
<h3 id="2-字符串拼接"><a href="#2-字符串拼接" class="headerlink" title="2.字符串拼接"></a>2.字符串拼接</h3><pre><code class="c#">string str2;
str2 = string.Format(&quot;&#123;0&#125;&#123;1&#125;&quot;, 111, 222);
</code></pre>
<h3 id="3-正向查找字符的位置"><a href="#3-正向查找字符的位置" class="headerlink" title="3.正向查找字符的位置"></a>3.正向查找字符的位置</h3><pre><code class="c#">str = &quot;我是聪哥&quot;;
int index = str.IndexOf(&quot;聪&quot;);                //返回2，若没找到返回 -1
</code></pre>
<h3 id="4-反向查找指定字符位置"><a href="#4-反向查找指定字符位置" class="headerlink" title="4.反向查找指定字符位置"></a>4.反向查找指定字符位置</h3><pre><code class="c#">string str3 = &quot;我是聪哥聪哥&quot;;
int index = str.LastIndexOf(&quot;聪哥&quot;);        //返回4
</code></pre>
<h3 id="5-移除指定位置后的字符"><a href="#5-移除指定位置后的字符" class="headerlink" title="5.移除指定位置后的字符"></a>5.移除指定位置后的字符</h3><pre><code class="c#">string str4 = &quot;我是聪哥&quot;;
str = str.Remove(3);                //将会移除第四个位置，注意不会直接移除原本的字符串，但会返回一个移除过字符串的值
str = str.Remove(1, 1);        //参数1开始位置，参数2字符个数
</code></pre>
<h3 id="6-替换指定字符"><a href="#6-替换指定字符" class="headerlink" title="6.替换指定字符"></a>6.替换指定字符</h3><pre><code class="c#">str = &quot;我是聪哥聪哥&quot;;
str = str.Replace(&quot;聪哥&quot;, &quot;哥聪&quot;);        //若找到 &quot;聪哥&quot; 字符将会替换成 &quot;哥聪&quot;，比如替换成&quot;我是哥聪哥聪&quot;，同样是返回值，但不改变原字符串
</code></pre>
<h3 id="7-大小写转换"><a href="#7-大小写转换" class="headerlink" title="7.大小写转换"></a>7.大小写转换</h3><pre><code class="c#">str = &quot;abcd&quot;;
str = str.ToUpper();        //内部所有字符都将替换成大写
str = str.ToLower();        //替换成小写
</code></pre>
<h3 id="8-字符串截取"><a href="#8-字符串截取" class="headerlink" title="8.字符串截取"></a>8.字符串截取</h3><pre><code class="c#">str = &quot;聪哥聪哥&quot;;
str = str.Substring(2);        //截取从指定位置开始之后的字符串，打印出“聪哥”
str = str.Substring(0, 3);        //参数一表示开始位置，参数二表示截取个数，打印出“聪哥聪”  若越界会报错
</code></pre>
<h3 id="9-字符串切割（非常重要）"><a href="#9-字符串切割（非常重要）" class="headerlink" title="9.字符串切割（非常重要）"></a>9.字符串切割（非常重要）</h3><pre><code class="c#">str = &quot;1,2,3,4,5,6,7,8&quot;;
string[] strs = str.Split(&#39; , &#39;);        //将会以逗号为标志，将12345678隔开
</code></pre>
<h3 id="10-string不管是重新赋值，还是-都会被分配新的堆空间"><a href="#10-string不管是重新赋值，还是-都会被分配新的堆空间" class="headerlink" title="10.string不管是重新赋值，还是+&#x3D;都会被分配新的堆空间"></a>10.string不管是重新赋值，还是+&#x3D;都会被分配新的堆空间</h3><h2 id="四、StringBuilder"><a href="#四、StringBuilder" class="headerlink" title="四、StringBuilder"></a>四、StringBuilder</h2><h3 id="1-基本概念-7"><a href="#1-基本概念-7" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><p>c#提供一个用于处理字符串的公共类<br>主要解决的问题是：<br>修改字符串而不创建新的对象<br>需要频繁修改和拼接的字符串可以使用它，可以提升性能<br>使用前，需要引用命名空间</p>
<h3 id="2-初始化-直接指明内容"><a href="#2-初始化-直接指明内容" class="headerlink" title="2.初始化 直接指明内容"></a>2.初始化 直接指明内容</h3><p>先  using System.Text;</p>
<pre><code class="c#">StringBuilder str = new StringBuilder(&quot;123123123&quot;);
StringBuilder str = new StringBuilder(&quot;123123123&quot;, 50);         //第二个参数是初始容量
</code></pre>
<h3 id="3-容量"><a href="#3-容量" class="headerlink" title="3.容量"></a>3.容量</h3><p>StringBuilder存在一个容量问题，会有一个初始容量，每次往里面增加时，会自动扩容（翻倍）<br>StringBuilder实际上还是会产生垃圾，只不过产生垃圾较少</p>
<pre><code class="c#">//获取容量
Console.Write(str.Capacity);
//s获得字符长度
Console.Write(str.Length);
</code></pre>
<h3 id="4-增删查改替换"><a href="#4-增删查改替换" class="headerlink" title="4.增删查改替换"></a>4.增删查改替换</h3><pre><code class="c#">//增加
str.Append(&quot;567567&quot;);
str.AppendFormat(&quot;&#123;0&#125;&#123;1&#125;&quot;, 111, 222);
//插入
str.Insert(0, &quot;聪哥&quot;);
//删
str.Remove(0, 3);
//清空
str.Clean();
//查
Console.Write(str[0]);
//改
str[0] = &#39;a&#39;;
//替换
str.Replace(&quot;5&quot;, &quot;聪&quot;);        //将 5 改成 聪        不需要重新赋值
//重新赋值
str.Clean();
str.Append(&quot;789789&quot;);        //可防止产生垃圾
//判断StringBuilder是否和某一个字符串相等
str.Equals(&quot;789789&quot;);
</code></pre>
<h3 id="5-如何优化内存"><a href="#5-如何优化内存" class="headerlink" title="5.如何优化内存"></a>5.如何优化内存</h3><p>从两方面来解答</p>
<ul>
<li>如何节约内存（内存满了，可能会崩溃）</li>
<li>如何尽量少用GC（频繁的GC会造成卡顿）<br>少new对象 少产生垃圾<br>合理使用static<br>合理使用string和StringBuilder</li>
</ul>
<h2 id="五、结构体和类的区别"><a href="#五、结构体和类的区别" class="headerlink" title="五、结构体和类的区别"></a>五、结构体和类的区别</h2><h3 id="1-区别概述"><a href="#1-区别概述" class="headerlink" title="1.区别概述"></a>1.区别概述</h3><p>结构体和类最大的区别是在存储空间上的，因为结构体是值，类是引用<br>因此他们存储位置一个在栈上，一个在堆上<br>通过之前知识点的学习，我相信你能够从此处看出他们在使用的区别——值和引用类型在赋值时的区别</p>
<p>结构体和类在使用上很类似，结构体甚至可以用面向对象的思想来形容一类对象<br>结构体具备着面向对象思想中封装的特性，但是它不具备继承和多态的特性，因此大大减少额它的使用频率<br>由于结构体不具备继承的特性，所以他不能用protected保护访问修饰符</p>
<h3 id="2-细节区别"><a href="#2-细节区别" class="headerlink" title="2.细节区别"></a>2.细节区别</h3><p>结构体是值类型，类是引用类型<br>结构体存在栈中，类存在堆中<br>结构体成员不能使用protected访问修饰符，而类可以<br>结构体成员变量申明不能指定初始值，而类可以<br>结构体不能申明无参的构造函数，而类可以<br>结构体申明有参构成函数后，无参构造不会被顶掉<br>结构体不能申明析构函数，而类可以<br>结构体不能被继承，而类可以<br>结构体需要在构造函数中初始化所有成员变量，而类随意<br>结构体不能被静态static修饰（不存在静态结构体），而类可以<br>结构体不能再内部申明和自己一样的结构体变量，而类可以</p>
<h3 id="3-结构体的特别之处"><a href="#3-结构体的特别之处" class="headerlink" title="3.结构体的特别之处"></a>3.结构体的特别之处</h3><p>结构体可以继承  接口</p>
<h3 id="4-如何选择结构体和类"><a href="#4-如何选择结构体和类" class="headerlink" title="4.如何选择结构体和类"></a>4.如何选择结构体和类</h3><p>想要用继承和多态时，直接淘汰结构体，比如玩家、怪物<br>对象是数据集合时，优先选择结构体，比如位置、坐标<br>从值类型和引用类型赋值时的区别上去考虑，比如经常被赋值传递的对象，并且改变赋值对象，原对象不想跟着变化时，就用结构体。比如坐标、向量、旋转等</p>
<h2 id="六、抽象类和接口的区别"><a href="#六、抽象类和接口的区别" class="headerlink" title="六、抽象类和接口的区别"></a>六、抽象类和接口的区别</h2><h3 id="1-相同点"><a href="#1-相同点" class="headerlink" title="1.相同点"></a>1.相同点</h3><p>都可以被继承<br>都不能直接实例化<br>都可以包含方法申明<br>子类必须实现未实现的方法<br>都遵循里氏替换原则原则</p>
<h3 id="2-区别"><a href="#2-区别" class="headerlink" title="2.区别"></a>2.区别</h3><p>抽象类中可以有构造函数，接口不行<br>抽象类只能被单一继承，接口可以被继承多个<br>抽象类中可以有成员变量，接口中不能<br>抽象类中可以申明成员方法、虚方法、抽象方法、静态方法，接口只能申明没有实现的抽象方法<br>抽象类中可以使用访问修饰符，接口中不建议使用，默认为public</p>
<h3 id="3-如何选择接口和抽象类"><a href="#3-如何选择接口和抽象类" class="headerlink" title="3.如何选择接口和抽象类"></a>3.如何选择接口和抽象类</h3><p>表示对象的用抽象类，表示行为拓展的用接口<br>不同对象拥有的共同行为，我们往往可以用接口来实现<br>例如：<br>动物是一类对象，使用抽象类，而飞行是一种行为，使用接口</p>
<h2 id="七、面向对象七大原则"><a href="#七、面向对象七大原则" class="headerlink" title="七、面向对象七大原则"></a>七、面向对象七大原则</h2><h3 id="1-为什么有七大原则"><a href="#1-为什么有七大原则" class="headerlink" title="1.为什么有七大原则"></a>1.为什么有七大原则</h3><p>七大原则总体要实现的目标是：<br>高内聚、低耦合<br>使程序模块的可重用性、移植性增强</p>
<p>高内聚低耦合<br>从类角度来看，减少类内部对其他类的调用<br>从功能块来看，减少模块间交互复杂度</p>
<h3 id="2-单一职责原则SRP（Single-Respondsibility-Principle）"><a href="#2-单一职责原则SRP（Single-Respondsibility-Principle）" class="headerlink" title="2.单一职责原则SRP（Single Respondsibility Principle）"></a>2.单一职责原则SRP（Single Respondsibility Principle）</h3><p>类被修改的几率很大，因此应该专注于单一的功能<br>如果把多个功能放到同一个类中，功能之间就形成了关联，改变其中一个功能，有可能终止另一个功能</p>
<p>例如<br>假设程序、策划、美术三个工种是三个类，他们应该各司其职，在程序世界中只应该做自己应该做的事情</p>
<h3 id="3-开闭原则OCP（Open-Closed-Principle）"><a href="#3-开闭原则OCP（Open-Closed-Principle）" class="headerlink" title="3.开闭原则OCP（Open-Closed Principle）"></a>3.开闭原则OCP（Open-Closed Principle）</h3><p>对拓展开发，对修改关闭<br>拓展开发：模块的行为可以被拓展，从而满足新的需求<br>修改关闭：不允许修改模块的源代码（或尽量使修改最小化）</p>
<p>例如<br>继承是最典型的开闭原则的体现，可以通过添加新的子类或者重写父类的方法来实现</p>
<h3 id="4-里氏替换原则LSP（Liskov-Substitution-Principle）"><a href="#4-里氏替换原则LSP（Liskov-Substitution-Principle）" class="headerlink" title="4.里氏替换原则LSP（Liskov Substitution Principle）"></a>4.里氏替换原则LSP（Liskov Substitution Principle）</h3><p>任何父类出现的地方，子类都可以替代</p>
<p>例如<br>用父类容器装载子类对象，因为子类对象包含了父类的所有内容</p>
<h3 id="5-依赖倒转原则DIP（Dependence-Inversion-Principle）"><a href="#5-依赖倒转原则DIP（Dependence-Inversion-Principle）" class="headerlink" title="5.依赖倒转原则DIP（Dependence Inversion Principle）"></a>5.依赖倒转原则DIP（Dependence Inversion Principle）</h3><p>要依赖于抽象，不要依赖于具体实现</p>
<p>例如<br>玩家类。手枪、机关枪，这两个都有开枪行为，将行为抽象出来，玩家只需要依赖于抽象出来的开枪接口，通过里氏替换原则，用开枪这个接口存储这两种枪。</p>
<h3 id="6-迪米特原则LoP（Law-of-Demeter）"><a href="#6-迪米特原则LoP（Law-of-Demeter）" class="headerlink" title="6.迪米特原则LoP（Law of Demeter）"></a>6.迪米特原则LoP（Law of Demeter）</h3><p>又称最少知识原则<br>一个对象应当对其他对象尽可能少的了解，不要和陌生人说话<br>也就是一个类里面要尽量少的拥有别的类</p>
<p>例如<br>一个对象中的成员，要尽可能少的直接和其他类建立关系。目的是降低耦合性</p>
<h3 id="7-接口分离原则ISP（Interface-Segregation-Principle）"><a href="#7-接口分离原则ISP（Interface-Segregation-Principle）" class="headerlink" title="7.接口分离原则ISP（Interface Segregation Principle）"></a>7.接口分离原则ISP（Interface Segregation Principle）</h3><p>不应该强迫别人依赖他们不需要使用的方法<br>一个接口不需要提供太多的行为<br>一个接口尽量只提供一个对外功能<br>让别人去选择需要实现什么样的行为，而不是把所有行为都封装到一个接口中</p>
<p>例如<br>飞行接口、走路接口、跑步接口等等，虽然都是移动行为，但我们应该把他们分为一个个单独的接口，让别人去选择使用</p>
<h3 id="8-合成复用原则CRP（Composite-Reuse-Principle）"><a href="#8-合成复用原则CRP（Composite-Reuse-Principle）" class="headerlink" title="8.合成复用原则CRP（Composite Reuse Principle）"></a>8.合成复用原则CRP（Composite Reuse Principle）</h3><p>尽量使用对象组合，而不是继承来达到复用的目的<br>继承关系时强耦合，组合关系时低耦合</p>
<p>例如<br>脸应该是眼睛、鼻子、嘴巴、耳朵的组合，而不是依次的继承。<br>角色和装备也应该是组合，而不是继承</p>
<p>注意：不能盲目的使用合成复用原则，要在遵循迪米特原则的前提上</p>
<h3 id="9-总结"><a href="#9-总结" class="headerlink" title="9.总结"></a>9.总结</h3><p>单一职责原则SRP（Single Respondsibility Principle）<br>一个类只处理自己应该处理的内容，不应该啥都写到一起</p>
<p>开闭原则OCP（Open-Closed Principle）<br>对拓展开放，对修改封闭。新功能尽量是加处理，而不是改代码</p>
<p>里氏替换原则LSP（Liskov Substitution Principle）<br>任何地方子类都能替代父类，父类容器装子类</p>
<p>依赖倒转原则DIP（Dependence Inversion Principle）<br>不要依赖具体的实现，要依赖抽象（接口）</p>
<p>迪米特原则LoP（Law of Demeter）<br>一个类要尽量减少对别的类的了解，尽量少用别的类与自己关联</p>
<p>接口分离原则ISP（Interface Segregation Principle）<br>一个接口一个行为，不要一个接口n个行为</p>
<p>合成复用原则CRP（Composite Reuse Principle）<br>除非设计上需要继承，否则尽量用组合复用的形式</p>
<h3 id="10-如何使用这些原则"><a href="#10-如何使用这些原则" class="headerlink" title="10.如何使用这些原则"></a>10.如何使用这些原则</h3><p>在开始做项目前，整理UML类图时<br>先按自己的想法把需要的类整理出来<br>在把七大原则的截图放出来，基于七大原则去优化自己的设计<br>整体目的就是        高内聚，低耦合</p>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 jaytp@qq.com </span>
    </div>
</article>







    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2024 Paul
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 562px;
    }
    .nav.fullscreen {
        margin-left: -562px;
    }
    .nav-left {
        width: 140px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 512px;
        }
        .nav.fullscreen {
            margin-left: -512px;
        }
        .nav-left {
            width: 120px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 512px;
            margin-left: -512px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
