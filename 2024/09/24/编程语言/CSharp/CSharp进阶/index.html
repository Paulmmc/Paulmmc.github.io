<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>CSharp进阶 | Paul的博客</title>
  <meta name="keywords" content=" CSharp ">
  <meta name="description" content="CSharp进阶 | Paul的博客">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="知识点一 认识模型的制作过程一、模型的制作过程建模：建模、展UV、材质和纹理贴图动作：骨骼绑定、动画制作 二、建模美术通过建模软件（3Dmax或Maya等）用一个个面片将模型制作出来面片：3点构成一个面，面的最小单位是三角形，建模时，可以使用3点以上的面，但是建议都使用三角面。网格信息：一般指的就是模型的这些顶点面片信息 三、展UVUV是纹理贴图坐标的简称，它有U轴和V轴，类似空间中的xyz轴。纹">
<meta property="og:type" content="article">
<meta property="og:title" content="Unity核心">
<meta property="og:url" content="https://paulmmc.github.io/2024/10/05/Unity%E6%A0%B8%E5%BF%83/index.html">
<meta property="og:site_name" content="Paul的博客">
<meta property="og:description" content="知识点一 认识模型的制作过程一、模型的制作过程建模：建模、展UV、材质和纹理贴图动作：骨骼绑定、动画制作 二、建模美术通过建模软件（3Dmax或Maya等）用一个个面片将模型制作出来面片：3点构成一个面，面的最小单位是三角形，建模时，可以使用3点以上的面，但是建议都使用三角面。网格信息：一般指的就是模型的这些顶点面片信息 三、展UVUV是纹理贴图坐标的简称，它有U轴和V轴，类似空间中的xyz轴。纹">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-10-05T07:53:05.000Z">
<meta property="article:modified_time" content="2024-10-05T07:54:56.419Z">
<meta property="article:author" content="Paul">
<meta property="article:tag" content="Unity">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 7.3.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>Paul</span>
</div>

<div class="icon">
    
        
    
        
            <a title="github"
               href="https://github.com/Paulmmc"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
            <a title="email"
               href="mailto:3095627551@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=3095627551&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(18)</small>
            
        </div>
    </li>
    
        
            
                
    <li>
        <div data-rel="Unity笔记">
            <i class="fold iconfont icon-right"></i>
            Unity笔记
            <small>(10)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="Unity笔记&lt;---&gt;Unity核心">
            
            Unity核心
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Unity笔记&lt;---&gt;Unity基础">
            
            Unity基础
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Unity笔记&lt;---&gt;Unity进阶">
            
            Unity进阶
            <small>(7)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Unity笔记&lt;---&gt;Unity入门">
            
            Unity入门
            <small>(1)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="理论基础">
            <i class="fold iconfont icon-right"></i>
            理论基础
            <small>(6)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="理论基础&lt;---&gt;编程语言">
            <i class="fold iconfont icon-right"></i>
            编程语言
            <small>(6)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="理论基础&lt;---&gt;编程语言&lt;---&gt;CSharp">
            
            CSharp
            <small>(4)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="CoscosCretor笔记">
            
            CoscosCretor笔记
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="18">
<input type="hidden" id="yelog_site_word_count" value="78.9k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>CSharp</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Unity</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="全部文章 Unity笔记 Unity核心 "
           href="/2024/10/05/Unity%E6%A0%B8%E5%BF%83/"
           data-tag="Unity"
           data-author="" >
            <span class="post-title" title="Unity核心">Unity核心</span>
            <span class="post-date" title="2024-10-05 15:53:05">2024/10/05</span>
        </a>
        
        
        <a  class="全部文章 Unity笔记 Unity基础 "
           href="/2024/10/04/Unity%E7%AC%94%E8%AE%B0/Unity%E5%9F%BA%E7%A1%80/"
           data-tag="Unity"
           data-author="" >
            <span class="post-title" title="Unity基础">Unity基础</span>
            <span class="post-date" title="2024-10-04 22:30:55">2024/10/04</span>
        </a>
        
        
        <a  class="全部文章 Unity笔记 Unity入门 "
           href="/2024/09/27/Unity%E7%AC%94%E8%AE%B0/Unity%E5%85%A5%E9%97%A8/"
           data-tag="Unity"
           data-author="" >
            <span class="post-title" title="Unity入门">Unity入门</span>
            <span class="post-date" title="2024-09-27 23:19:29">2024/09/27</span>
        </a>
        
        
        <a  class="全部文章 理论基础 编程语言 CSharp "
           href="/2024/09/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/CSharp/CSharp%E8%BF%9B%E9%98%B6/"
           data-tag="CSharp"
           data-author="" >
            <span class="post-title" title="CSharp进阶">CSharp进阶</span>
            <span class="post-date" title="2024-09-24 23:02:43">2024/09/24</span>
        </a>
        
        
        <a  class="全部文章 理论基础 编程语言 CSharp "
           href="/2024/09/23/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/CSharp/CSharp%E6%A0%B8%E5%BF%83/"
           data-tag="CSharp"
           data-author="" >
            <span class="post-title" title="CSharp核心">CSharp核心</span>
            <span class="post-date" title="2024-09-23 23:16:21">2024/09/23</span>
        </a>
        
        
        <a  class="全部文章 理论基础 编程语言 CSharp "
           href="/2024/09/23/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/CSharp/CSharp%E5%9F%BA%E7%A1%80/"
           data-tag="CSharp"
           data-author="" >
            <span class="post-title" title="CSharp基础">CSharp基础</span>
            <span class="post-date" title="2024-09-23 22:07:32">2024/09/23</span>
        </a>
        
        
        <a  class="全部文章 理论基础 编程语言 CSharp "
           href="/2024/09/23/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/CSharp/CSharp%E5%85%A5%E9%97%A8/"
           data-tag="CSharp"
           data-author="" >
            <span class="post-title" title="CSharp入门">CSharp入门</span>
            <span class="post-date" title="2024-09-23 20:18:42">2024/09/23</span>
        </a>
        
        
        <a  class="全部文章 Unity笔记 Unity进阶 "
           href="/2024/09/23/Unity%E7%AC%94%E8%AE%B0/Unity%E8%BF%9B%E9%98%B6/InputSystem/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="InputSystem">InputSystem</span>
            <span class="post-date" title="2024-09-23 18:11:34">2024/09/23</span>
        </a>
        
        
        <a  class="全部文章 CoscosCretor笔记 "
           href="/2024/09/23/CocosCreator%E7%AC%94%E8%AE%B0/TS/TypeScript%E8%AF%AD%E8%A8%80/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="TypeScript语言">TypeScript语言</span>
            <span class="post-date" title="2024-09-23 18:00:16">2024/09/23</span>
        </a>
        
        
        <a  class="全部文章 Unity笔记 Unity进阶 "
           href="/2024/09/23/Unity%E7%AC%94%E8%AE%B0/Unity%E8%BF%9B%E9%98%B6/Excel%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Excel数据读取">Excel数据读取</span>
            <span class="post-date" title="2024-09-23 18:00:16">2024/09/23</span>
        </a>
        
        
        <a  class="全部文章 Unity笔记 Unity进阶 "
           href="/2024/09/23/Unity%E7%AC%94%E8%AE%B0/Unity%E8%BF%9B%E9%98%B6/GameFramework/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="GameFramework">GameFramework</span>
            <span class="post-date" title="2024-09-23 18:00:16">2024/09/23</span>
        </a>
        
        
        <a  class="全部文章 Unity笔记 Unity进阶 "
           href="/2024/09/23/Unity%E7%AC%94%E8%AE%B0/Unity%E8%BF%9B%E9%98%B6/Unity%E4%B8%AD%E7%9A%84MVC%E6%80%9D%E6%83%B3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Unity中的MVC思想">Unity中的MVC思想</span>
            <span class="post-date" title="2024-09-23 18:00:16">2024/09/23</span>
        </a>
        
        
        <a  class="全部文章 Unity笔记 Unity进阶 "
           href="/2024/09/23/Unity%E7%AC%94%E8%AE%B0/Unity%E8%BF%9B%E9%98%B6/Unity%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%8B2%E8%BF%9B%E5%88%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Unity数据持久化之2进制">Unity数据持久化之2进制</span>
            <span class="post-date" title="2024-09-23 18:00:16">2024/09/23</span>
        </a>
        
        
        <a  class="全部文章 Unity笔记 Unity进阶 "
           href="/2024/09/23/Unity%E7%AC%94%E8%AE%B0/Unity%E8%BF%9B%E9%98%B6/Unity%E7%BC%96%E8%BE%91%E5%99%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Unity编辑器">Unity编辑器</span>
            <span class="post-date" title="2024-09-23 18:00:16">2024/09/23</span>
        </a>
        
        
        <a  class="全部文章 Unity笔记 Unity进阶 "
           href="/2024/09/23/Unity%E7%AC%94%E8%AE%B0/Unity%E8%BF%9B%E9%98%B6/Unity%E7%BD%91%E7%BB%9C%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Unity网络开发基础">Unity网络开发基础</span>
            <span class="post-date" title="2024-09-23 18:00:16">2024/09/23</span>
        </a>
        
        
        <a  class="全部文章 理论基础 编程语言 "
           href="/2024/09/23/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/C++/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="C++">C++</span>
            <span class="post-date" title="2024-09-23 18:00:16">2024/09/23</span>
        </a>
        
        
        <a  class="全部文章 理论基础 编程语言 "
           href="/2024/09/23/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/TypeScript/TypeScript%E8%AF%AD%E8%A8%80/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="TypeScript">TypeScript</span>
            <span class="post-date" title="2024-09-23 18:00:16">2024/09/23</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2024/09/21/hello-world/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Hello World">Hello World</span>
            <span class="post-date" title="2024-09-21 00:02:38">2024/09/21</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-编程语言/CSharp/CSharp进阶" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">CSharp进阶</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="理论基础">理论基础</a> > 
            
            <a  data-rel="理论基础&lt;---&gt;编程语言">编程语言</a> > 
            
            <a  data-rel="理论基础&lt;---&gt;编程语言&lt;---&gt;CSharp">CSharp</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color2">CSharp</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2024-09-27 23:15:19'>2024-09-24 23:02</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:12.8k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80-%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B1%BB"><span class="toc-text">知识点一 简单数据结构类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81ArrayList"><span class="toc-text">一、ArrayList</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-ArrayList%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-text">1.ArrayList的本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%94%B3%E6%98%8E"><span class="toc-text">2.申明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9"><span class="toc-text">3.增删查改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1"><span class="toc-text">4.装箱拆箱</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Stack"><span class="toc-text">二、Stack</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Stack%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-text">1.Stack的本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%94%B3%E6%98%8E-1"><span class="toc-text">2.申明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A2%9E%E5%8F%96%E6%9F%A5%E6%94%B9"><span class="toc-text">3.增取查改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%81%8D%E5%8E%86"><span class="toc-text">4.遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1"><span class="toc-text">5.装箱拆箱</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Queue"><span class="toc-text">三、Queue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Queue%E6%9C%AC%E8%B4%A8"><span class="toc-text">1.Queue本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%94%B3%E6%98%8E-2"><span class="toc-text">2.申明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A2%9E%E5%8F%96%E6%9F%A5%E6%94%B9-1"><span class="toc-text">3.增取查改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%81%8D%E5%8E%86-1"><span class="toc-text">4.遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1-1"><span class="toc-text">5.装箱拆箱</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Hashtable"><span class="toc-text">四、Hashtable</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Hashtable%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-text">1.Hashtable的本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E7%94%B3%E6%98%8E"><span class="toc-text">2.如何申明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9-1"><span class="toc-text">3.增删查改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%81%8D%E5%8E%86-2"><span class="toc-text">4.遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1-2"><span class="toc-text">5.装箱拆箱</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C-%E6%B3%9B%E5%9E%8B"><span class="toc-text">知识点二 泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%B3%9B%E5%9E%8B"><span class="toc-text">一、泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%B3%9B%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">1.泛型是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B3%9B%E5%9E%8B%E5%88%86%E7%B1%BB"><span class="toc-text">2.泛型分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="toc-text">3.泛型类和接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-text">4.泛型方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">5.泛型的作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-text">二、泛型约束</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-text">1.什么是泛型约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%90%84%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-text">2.各泛型约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BA%A6%E6%9D%9F%E7%9A%84%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8"><span class="toc-text">3.约束的组合使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%A4%9A%E4%B8%AA%E6%B3%9B%E5%9E%8B%E6%9C%89%E7%BA%A6%E6%9D%9F"><span class="toc-text">4.多个泛型有约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%B3%9B%E5%9E%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%9F%BA%E7%B1%BB%EF%BC%88%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%8F%AF%E7%9B%B4%E6%8E%A5%E7%BB%A7%E6%89%BF%EF%BC%8C%E5%8F%AF%E5%A2%9E%E5%8A%A0%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8%EF%BC%8C%E5%87%8F%E5%B0%91%E4%BB%A3%E7%A0%81%E9%87%8F%EF%BC%89"><span class="toc-text">5.泛型单例模式基类（单例模式可直接继承，可增加代码重用，减少代码量）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89-%E5%B8%B8%E7%94%A8%E6%B3%9B%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B1%BB"><span class="toc-text">知识点三 常用泛型数据结构类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81List"><span class="toc-text">一、List</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-List%E6%9C%AC%E8%B4%A8"><span class="toc-text">1.List本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%94%B3%E6%98%8E-3"><span class="toc-text">2.申明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9-2"><span class="toc-text">3.增删查改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%81%8D%E5%8E%86-3"><span class="toc-text">4.遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Dictionary"><span class="toc-text">二、Dictionary</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Dictionary%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-text">1.Dictionary的本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%94%B3%E6%98%8E-4"><span class="toc-text">2.申明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9-3"><span class="toc-text">3.增删查改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%81%8D%E5%8E%86-4"><span class="toc-text">4.遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%92%8C%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-text">三、顺序存储和链式存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">1.数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-text">2.线性表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-text">3.顺序存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-text">4.链式存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-text">5.自己实现一个最简单的单向链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%92%8C%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">6.顺序存储和链式存储的优缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81LinkedList"><span class="toc-text">四、LinkedList</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-LinkedList"><span class="toc-text">1.LinkedList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%94%B3%E6%98%8E-5"><span class="toc-text">2.申明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9-4"><span class="toc-text">3.增删查改</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%B3%9B%E5%9E%8B%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-text">五、泛型栈和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9B%9E%E9%A1%BE%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8"><span class="toc-text">1.回顾数据容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B3%9B%E5%9E%8B%E6%A0%88%E5%92%8C%E6%B3%9B%E5%9E%8B%E9%98%9F%E5%88%97"><span class="toc-text">2.泛型栈和泛型队列</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B-%E5%A7%94%E6%89%98%E5%92%8C%E4%BA%8B%E4%BB%B6"><span class="toc-text">知识点四 委托和事件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%A7%94%E6%89%98"><span class="toc-text">一、委托</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%A7%94%E6%89%98%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">1.委托是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-text">2.基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AE%9A%E4%B9%89%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A7%94%E6%89%98"><span class="toc-text">3.定义自定义委托</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8%E5%AE%9A%E4%B9%89%E5%A5%BD%E7%9A%84%E5%A7%94%E6%89%98"><span class="toc-text">4.使用定义好的委托</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%A7%94%E6%89%98%E5%8F%98%E9%87%8F%E5%8F%AF%E4%BB%A5%E5%AD%98%E5%82%A8%E5%A4%9A%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%88%E5%A4%9A%E6%92%AD%E5%A7%94%E6%89%98%EF%BC%89"><span class="toc-text">5.委托变量可以存储多个函数（多播委托）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%B3%BB%E7%BB%9F%E5%AE%9A%E4%B9%89%E5%A5%BD%E7%9A%84%E5%A7%94%E6%89%98"><span class="toc-text">6.系统定义好的委托</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%BA%8B%E4%BB%B6"><span class="toc-text">二、事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BA%8B%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">1.事件是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">2.事件的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E4%BA%8B%E4%BB%B6"><span class="toc-text">3.为什么有事件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-text">三、匿名函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-text">1.什么是匿名函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-1"><span class="toc-text">2.基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8"><span class="toc-text">3.使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-text">4.匿名函数的缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Lambad%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">四、Lambad表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFlambad%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">1.什么是lambad表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-lambad%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95"><span class="toc-text">2.lambad表达式语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8-1"><span class="toc-text">3.使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%97%AD%E5%8C%85"><span class="toc-text">4.闭包</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%94-List%E6%8E%92%E5%BA%8F"><span class="toc-text">知识点五 List排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E5%85%AD-%E5%8D%8F%E5%8F%98%E9%80%86%E5%8F%98"><span class="toc-text">知识点六 协变逆变</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%83-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">知识点七 多线程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E5%85%AB-%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E6%8C%87%E4%BB%A4"><span class="toc-text">知识点八 预处理器指令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-text">一、什么是编译器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E6%8C%87%E4%BB%A4"><span class="toc-text">二、什么是预处理器指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4"><span class="toc-text">三、常见的预处理指令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B9%9D-%E5%8F%8D%E5%B0%84"><span class="toc-text">知识点九 反射</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A6%82%E5%BF%B5%E5%92%8C%E5%85%B3%E9%94%AE%E7%B1%BBType"><span class="toc-text">一、概念和关键类Type</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%A8%8B%E5%BA%8F%E9%9B%86"><span class="toc-text">1.什么是程序集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%85%83%E6%95%B0%E6%8D%AE"><span class="toc-text">2.元数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8F%8D%E5%B0%84%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">3.反射的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">4.反射的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%AF%AD%E6%B3%95%E7%9B%B8%E5%85%B3"><span class="toc-text">5.语法相关</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%85%B3%E9%94%AE%E7%B1%BBAssembly%E5%92%8CActivator"><span class="toc-text">二、关键类Assembly和Activator</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Activator"><span class="toc-text">1.Activator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Assembly"><span class="toc-text">2.Assembly</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%B1%BB%E5%BA%93%E5%B7%A5%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="toc-text">3.类库工程创建</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E5%8D%81-%E7%89%B9%E6%80%A7"><span class="toc-text">知识点十 特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%89%B9%E6%80%A7%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">一、特性是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%89%B9%E6%80%A7"><span class="toc-text">二、自定义特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%89%B9%E6%80%A7%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">三、特性的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%99%90%E5%88%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E7%89%B9%E6%80%A7%E7%9A%84%E4%BD%BF%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="toc-text">四、限制自定义特性的使用范围</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%B8%A6%E7%89%B9%E6%80%A7-%E2%80%94%E2%80%94-%E8%BF%87%E6%97%B6%E7%89%B9%E6%80%A7"><span class="toc-text">五、系统自带特性 —— 过时特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%B8%A6%E7%89%B9%E6%80%A7-%E2%80%94%E2%80%94-%E8%B0%83%E7%94%A8%E8%80%85%E4%BF%A1%E6%81%AF%E7%89%B9%E6%80%A7"><span class="toc-text">六、系统自带特性 —— 调用者信息特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%B8%A6%E7%89%B9%E6%80%A7-%E2%80%94%E2%80%94-%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91%E7%89%B9%E6%80%A7"><span class="toc-text">七、系统自带特性 —— 条件编译特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%B8%A6%E7%89%B9%E6%80%A7-%E2%80%94%E2%80%94-%E5%A4%96%E9%83%A8Dll%E5%8C%85%E5%87%BD%E6%95%B0%E7%89%B9%E6%80%A7"><span class="toc-text">八、系统自带特性 —— 外部Dll包函数特性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E5%8D%81%E4%B8%80-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">知识点十一 迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">一、迭代器是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%A0%87%E5%87%86%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-text">二、标准的迭代器实现方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%94%A8yield-return-%E8%AF%AD%E6%B3%95%E7%B3%96%E5%AE%9E%E7%8E%B0%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">三、用yield return 语法糖实现迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%94%A8yield-return-%E8%AF%AD%E6%B3%95%E7%B3%96%E4%B8%BA%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%AE%9E%E7%8E%B0%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">四、用yield return 语法糖为泛型类实现迭代器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E5%8D%81%E4%BA%8C-%E7%89%B9%E6%AE%8A%E8%AF%AD%E6%B3%95"><span class="toc-text">知识点十二 特殊语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81var%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B"><span class="toc-text">一、var隐式类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%80%BC"><span class="toc-text">二、设置对象初始值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E8%AE%BE%E7%BD%AE%E9%9B%86%E5%90%88%E5%88%9D%E5%A7%8B%E5%80%BC"><span class="toc-text">三、设置集合初始值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%8C%BF%E5%90%8D%E7%B1%BB%E5%9E%8B"><span class="toc-text">四、匿名类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%8F%AF%E7%A9%BA%E7%B1%BB%E5%9E%8B"><span class="toc-text">五、可空类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E7%A9%BA%E5%90%88%E5%B9%B6%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">六、空合并操作符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%86%85%E6%8F%92%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">七、内插字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E5%8D%95%E5%8F%A5%E9%80%BB%E8%BE%91%E7%9A%84%E7%AE%80%E7%95%A5%E5%86%99%E6%B3%95"><span class="toc-text">八、单句逻辑的简略写法</span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="知识点一-简单数据结构类"><a href="#知识点一-简单数据结构类" class="headerlink" title="知识点一 简单数据结构类"></a>知识点一 简单数据结构类</h1><h2 id="一、ArrayList"><a href="#一、ArrayList" class="headerlink" title="一、ArrayList"></a>一、ArrayList</h2><h3 id="1-ArrayList的本质"><a href="#1-ArrayList的本质" class="headerlink" title="1.ArrayList的本质"></a>1.ArrayList的本质</h3><p>ArrayList是一个c#为我们封装好的类<br>它本质是一个object类型的数组<br>ArrayList帮助我们实现了很多方法<br>比如数组的增删查改</p>
<h3 id="2-申明"><a href="#2-申明" class="headerlink" title="2.申明"></a>2.申明</h3><p>申明前必须引用</p>
<pre><code class="c#">using System.Collections;
ArrayList array = new ArrayList();
</code></pre>
<h3 id="3-增删查改"><a href="#3-增删查改" class="headerlink" title="3.增删查改"></a>3.增删查改</h3><ol>
<li>增</li>
</ol>
<pre><code class="c#">array.add(1);
array.add(&quot;123&quot;);
array.Insert(1, &quot;123456&quot;);        //在1位置插入元素123456
由于ArrayList是object类型，所以可以存储所有类型
</code></pre>
<ol start="2">
<li>范围增加</li>
</ol>
<pre><code class="c#">ArrayList array2 = new ArrayList();       
array2.add(567);
array.AddRange(array2);        //将array2里面的所有东西都加入到array后面
</code></pre>
<ol start="3">
<li>删</li>
</ol>
<pre><code class="c#">array.Remove(1);        //删除array数组里面的 &quot; 1 &quot; 元素，如果重名，则优先删除靠前的
array.RemoveAt(2);        //移除第三个位置的元素，也就是数组[2]的元素
array.Clear();                //清除所有元素
</code></pre>
<ol start="4">
<li>查</li>
</ol>
<pre><code class="c#">Console.Write(array[0]);                //查找0位置的元素
if(array.Contains(&quot;123&quot;))                //查看&quot;123&quot;元素是否存在，返回一个bool值
&#123;

&#125;
int index = array.IndexOf(1);        //正向查找元素，返回一个整形代表位置，若查不到则返回-1，若有重名则值返回靠前的元素
int index = array.LastIndexOf();        //反向查找元素，返回的整形是正向的索引，
</code></pre>
<ol start="5">
<li>改</li>
</ol>
<pre><code class="c#">array[0] = &quot;999&quot;;
</code></pre>
<ol start="6">
<li>遍历</li>
</ol>
<pre><code class="c#">array.Count                //长度
array.Capacity                //容量
for(int i = 0; i &lt; array.Count; i++)
&#123;
        Console.WriteLine(array[i] );
&#125;
迭代器遍历
foreach( object item in array)        变量类型  名字 in 数组
&#123;
        Console.WriteLine(item);
&#125;
</code></pre>
<h3 id="4-装箱拆箱"><a href="#4-装箱拆箱" class="headerlink" title="4.装箱拆箱"></a>4.装箱拆箱</h3><p>ArrayList本质上是一个可以自动扩容的object数组<br>由于用万物之父来存储数据类型，自然存在装箱拆箱<br>当往其中进行值类型存储时，就是在装箱，当将值类型对象取出来转换使用时，就是拆箱<br>所以为提高性能，ArrayList尽量少用，之后我们会学习更好的数据容器</p>
<pre><code class="c#">int i = 1;
array[2] = 1;                        //装箱
i = (int)array[2];                        //拆箱
</code></pre>
<h2 id="二、Stack"><a href="#二、Stack" class="headerlink" title="二、Stack"></a>二、Stack</h2><h3 id="1-Stack的本质"><a href="#1-Stack的本质" class="headerlink" title="1.Stack的本质"></a>1.Stack的本质</h3><p>Stack（栈）是一个C#为我们封装好的类<br>它的本质也是object[ ]数组，只是封装了特殊的存储规则<br>Stack是栈存储容器，栈是一种先进后出的数据结构<br>先存入的数据后获取，后存入的数据先获取<br>栈是先进后出的</p>
<h3 id="2-申明-1"><a href="#2-申明-1" class="headerlink" title="2.申明"></a>2.申明</h3><p>申明前先引用命名空间</p>
<pre><code class="c#">using System.Collections
Stack stack = new Stack();
</code></pre>
<h3 id="3-增取查改"><a href="#3-增取查改" class="headerlink" title="3.增取查改"></a>3.增取查改</h3><ol>
<li>增</li>
</ol>
<pre><code class="c#">//压栈
stack.Push(1);
stack.Push(&quot;123&quot;);
stack.Push(true);
</code></pre>
<ol start="2">
<li>取</li>
</ol>
<pre><code class="c#">//栈中不存在删的概念
//只有取的概念
//弹栈
object v = stack.Pop();                //先取出最后一个存入的元素，返回一个元素
Console.Write(v);                        //打印出“true”
</code></pre>
<ol start="3">
<li>查</li>
</ol>
<pre><code class="c#">//栈无法查看指定位置的元素
//只能查看栈顶的内容
object a = stack.Peek();        //查看栈顶内容，但不弹出
Console.Write(a);                //打印出栈顶的内容，即是最后一个存入的内容

//查看元素是否存在于栈中
if( stack.Contains(&quot;123&quot;))        //返回一个bool值
&#123;

&#125;
</code></pre>
<ol start="4">
<li>改</li>
</ol>
<pre><code class="c#">//栈是无法改变其中的元素的，只能压栈和弹栈
//实在要改只能清空
stack.Clear();        //清空
</code></pre>
<h3 id="4-遍历"><a href="#4-遍历" class="headerlink" title="4.遍历"></a>4.遍历</h3><pre><code class="c#">//a.长度
Console.WriteLine(stack.Count);

//b.用foreach遍历（栈没有索引器，不能用for循环遍历）
//遍历的顺序也是栈顶到栈低
foreach(object item in stack)
&#123;
    Console.WriteLine(item);
&#125;

//c.另一种遍历方法
//将栈转换为object数组
//遍历的顺序也是从栈顶到栈低
object[] array = stack.ToArray();        //将Stack类转object的数组
for(int i = 0; i &lt; array.Length; i++)
&#123;

&#125;

//d.循环弹栈（常用）
while(stack.Count &gt; 0)
&#123;
    object o = stack.Pop();
    Console.WriteLine(o);
&#125;
</code></pre>
<h3 id="5-装箱拆箱"><a href="#5-装箱拆箱" class="headerlink" title="5.装箱拆箱"></a>5.装箱拆箱</h3><p>由于用万物之父类来存储数据，自然存在装箱拆箱<br>当往其中进行值类型存储时就是装箱<br>当讲值类型对象取出来转换使用时，就存在拆箱</p>
<h2 id="三、Queue"><a href="#三、Queue" class="headerlink" title="三、Queue"></a>三、Queue</h2><h3 id="1-Queue本质"><a href="#1-Queue本质" class="headerlink" title="1.Queue本质"></a>1.Queue本质</h3><p>Queue（队列）是一个CSharo为我们封装好的类<br>它本质也是object数组，只是封装了特殊的存储规则</p>
<p>Queue是队列存储容器<br>队列是一种先进先出的存储结构<br>先存入的数据先获取，后存入的数据后获取<br>先进先出</p>
<h3 id="2-申明-2"><a href="#2-申明-2" class="headerlink" title="2.申明"></a>2.申明</h3><p>先引用命名空间</p>
<pre><code class="c#">using System.Collections
Queue queue = new Queue();
</code></pre>
<h3 id="3-增取查改-1"><a href="#3-增取查改-1" class="headerlink" title="3.增取查改"></a>3.增取查改</h3><ol>
<li>增</li>
</ol>
<pre><code class="c#">queue.Enqueue(1);
queue.Enqueue(1.4f);
queue.Enqueue(&quot;123&quot;);
</code></pre>
<ol start="2">
<li>取</li>
</ol>
<pre><code class="c#">//不存在删除，只存在取，先取出先存入的对象
object v = queue.Dequeue();
Console.Write(v);                //打印出  1
</code></pre>
<ol start="3">
<li>查</li>
</ol>
<pre><code class="c#">//查看队列头部元素但不移除
v = queue.Peek();                        //头部即第一个存入的元素
//查看元素是否存在于队列中
if(queue.Contains(1.4f))        //若存在返回true
&#123;
        
&#125;
</code></pre>
<ol start="4">
<li>改</li>
</ol>
<pre><code class="c#">//队列无法改变其中的元素，只能进出队列
//实在要改，只能清除
queue.Clear();
</code></pre>
<h3 id="4-遍历-1"><a href="#4-遍历-1" class="headerlink" title="4.遍历"></a>4.遍历</h3><pre><code class="c#">//a.长度
Console.WriteLine(queue.Count);

//b.foreach遍历
foreach( object item in queue)                //顺序是先进先出
&#123;
    Console.WriteLine(item);
&#125;

//c.另一种遍历方法
object[] array = queue.ToArray();
for(int i = 0; i &lt; arrat.Length; i++)
&#123;
        
&#125;

//d.循环出列
while(queue.Count &gt; 0)
&#123;
    object o = queue.Dequeue();
&#125;
</code></pre>
<h3 id="5-装箱拆箱-1"><a href="#5-装箱拆箱-1" class="headerlink" title="5.装箱拆箱"></a>5.装箱拆箱</h3><p>由于用万物之父来存储容器，自然存在装箱拆箱<br>当往其中进行值类型存储时，就是装箱<br>当将值类型对象取出来转换使用时，就是拆箱</p>
<h2 id="四、Hashtable"><a href="#四、Hashtable" class="headerlink" title="四、Hashtable"></a>四、Hashtable</h2><h3 id="1-Hashtable的本质"><a href="#1-Hashtable的本质" class="headerlink" title="1.Hashtable的本质"></a>1.Hashtable的本质</h3><p>Hashtable（哈希表、散列表），是基于键的哈希代码组织起来的，键 &#x2F; 值对<br>它的主要作用是提高数值查询的效率<br>使用键来访问集合中的元素</p>
<h3 id="2-如何申明"><a href="#2-如何申明" class="headerlink" title="2.如何申明"></a>2.如何申明</h3><p>申明前需要先引用命名空间</p>
<pre><code class="c#">using System.Collections
Hashtable hashtable = new Hashtable();
</code></pre>
<h3 id="3-增删查改-1"><a href="#3-增删查改-1" class="headerlink" title="3.增删查改"></a>3.增删查改</h3><ol>
<li>增</li>
</ol>
<pre><code class="c#">hashtable.Add(1, &quot;123&quot;);                //表示1这个键对应  &quot;123&quot;这个值
hashtable.Add(123, 1);                //表示&quot;123&quot;这个键对应 1这个整形
hashtable.Add(true, false)
//也是object类型，可以存任何类型
//注意：不能出现相同的键，值可以重复
</code></pre>
<ol start="2">
<li>删</li>
</ol>
<pre><code class="c#">//a.只能通过键去删除
hashtable.Remove(1);                //删除1键对应的&quot;123&quot;这个值，填键，不要填值

//b.删除不存在的键，没反应，不会报错

//c.或者直接清空
hashtable.Clear();
</code></pre>
<ol start="3">
<li>查</li>
</ol>
<pre><code class="c#">//a.通过键查看值，找不到返回null，不会报错
Console.Write(hashtable[1]);        //索引中填1，会打印1键对应的&quot;123&quot;值

//b.查看是否存在
//根据键检测
if( hashtable.Contains(2) )        //查看有没有2作为键的键值对
&#123;

&#125;
//或者
if(hashtable.ContainsKey(2))        //与上面一样
&#123;

&#125;

//根据值查看
if( hashtable.ContainsValue(&quot;123&quot;) )        //查看是否存在以&quot;123&quot;为值的键值对
&#123;

&#125;
</code></pre>
<ol start="4">
<li>改</li>
</ol>
<pre><code class="c#">只能改键对应的值内容，无法改键
hashtable[1] = 1.5f;        //将1键对应的值改为1.5f
</code></pre>
<h3 id="4-遍历-2"><a href="#4-遍历-2" class="headerlink" title="4.遍历"></a>4.遍历</h3><pre><code class="c#">//得到 键值对 对数
Console.Write(hashtable.Count);

//a.遍历所有键
foreach(object item in hashtable.Keys)        //注意要 .Keys，得到键
&#123;
    Console.WriteLine(item);                        //打印出键，打印顺序自己的规则
    Console.WriteLine(hashtable[item]);        //打印出键对应的值
&#125;

//b.遍历所有值
foreach(object item in hashtable.Values)        //注意要 .Values，得到值
&#123;
    Console.WriteLine(item);
&#125;

//c.键值对一起遍历
foreach(DictionaryEntry item in hashtable)
&#123;
    Console.WriteLine(item.Key);                //打印键
    Console.WriteLine(item.Value);                //打印值
&#125;

//d.迭代器遍历法
IDictionaryEnumerator myEnumerator = hashtable.GetEnumerator();
bool flag = myEnumerator.MoveNext();
while(flag)
&#123;
    Console.WriteLine(myEnumerator.Key);                //打印键
    Console.WriteLine(myEnumerator.Value);                //打印值
    flag = myEnumerator.MoveNext();
&#125;
</code></pre>
<h3 id="5-装箱拆箱-2"><a href="#5-装箱拆箱-2" class="headerlink" title="5.装箱拆箱"></a>5.装箱拆箱</h3><p>由于用万物之父存储数据，自然存在装箱拆箱<br>当往其中存储值时，就是在装箱<br>当将值类型取出来使用时，就是在拆箱</p>
<h1 id="知识点二-泛型"><a href="#知识点二-泛型" class="headerlink" title="知识点二 泛型"></a>知识点二 泛型</h1><h2 id="一、泛型"><a href="#一、泛型" class="headerlink" title="一、泛型"></a>一、泛型</h2><h3 id="1-泛型是什么"><a href="#1-泛型是什么" class="headerlink" title="1.泛型是什么"></a>1.泛型是什么</h3><p>泛型实现了类型参数化，达到代码重用的目的<br>通过类型参数化来实现同一份代码上操作多种类型</p>
<p>泛型相当于类型占位符<br>定义类或方法时，使用替代符代表变量类型<br>当真正使用类或方法时在具体指定类型</p>
<h3 id="2-泛型分类"><a href="#2-泛型分类" class="headerlink" title="2.泛型分类"></a>2.泛型分类</h3><p>泛型类和泛型接口<br>基本语法：<br>class 类名&lt;泛型占位字母&gt;<br>interface 接口名&lt;泛型占位字母&gt;</p>
<p>泛型函数<br>基本语法：函数名&lt;泛型占位字母&gt;(参数列表)</p>
<p>注意：占位符可以有多个，靠逗号隔开</p>
<h3 id="3-泛型类和接口"><a href="#3-泛型类和接口" class="headerlink" title="3.泛型类和接口"></a>3.泛型类和接口</h3><p>泛型类</p>
<pre><code class="c#">public TestClass&lt;T&gt;                //尖括号内的字母一般写大写，可写多个
&#123;
        public T value;
&#125;
//使用时
TestClass&lt;int&gt; t = new TestClass&lt;int&gt;();       //中括号中可以填写16种变量类型、枚举、自定义类，类中的value是int

interface TestInterface&lt;T&gt;
&#123;
        T Value
        &#123;
                get;
                set;
        &#125;
&#125;
//继承时
class Test : TestInterface&lt;int&gt;        //继承时，相当于要使用，不能填T
</code></pre>
<h3 id="4-泛型方法"><a href="#4-泛型方法" class="headerlink" title="4.泛型方法"></a>4.泛型方法</h3><ol>
<li>普通类中的泛型方法</li>
</ol>
<pre><code class="c#">class Test
&#123;
        public void TestFun&lt;T&gt;( T value )                //两个T要填相同的类型
        &#123;
                Console.WriteLine(value);
        &#125;
        public void TestFun&lt;T&gt;()
        &#123;
                T t = default(T);
        &#125;
        public T TestFun&lt;T&gt;(int i )
        &#123;
                return default(T);
        &#125;
&#125;
//使用时
Test t = new Test();
t.TestFun&lt;string&gt;(&quot;聪哥&quot;);                //两个T要填相同的类型
</code></pre>
<ol start="2">
<li>泛型类中的泛型方法</li>
</ol>
<pre><code class="c#">class Test&lt;T&gt;                //泛型类和普通类可以重名
&#123;
        public T value;
        public void TestFun&lt;K&gt;()                //泛型函数中的泛型占位字母不能和类的相同
        &#123;
                
        &#125;
&#125;
</code></pre>
<h3 id="5-泛型的作用"><a href="#5-泛型的作用" class="headerlink" title="5.泛型的作用"></a>5.泛型的作用</h3><p>不同类型对象的相同逻辑处理<br>使用泛型可以一定程度避免装箱拆箱<br>例如，优化ArrayList</p>
<h2 id="二、泛型约束"><a href="#二、泛型约束" class="headerlink" title="二、泛型约束"></a>二、泛型约束</h2><h3 id="1-什么是泛型约束"><a href="#1-什么是泛型约束" class="headerlink" title="1.什么是泛型约束"></a>1.什么是泛型约束</h3><p>让泛型的类型有一定限制<br>关键字：where<br>一共六种</p>
<ul>
<li>值类型                        where 泛型字母: struct</li>
<li>引用类型                      where 泛型字母:class</li>
<li>存在无参公共构造函数          where 泛型字母:new()</li>
<li>某个类本身或其派生类          where 泛型字母:类名</li>
<li>某个接口的派生类型            where 泛型字母:接口名</li>
<li>另一个泛型类型本身或其派生    where 泛型字母:另一个泛型字母</li>
</ul>
<h3 id="2-各泛型约束"><a href="#2-各泛型约束" class="headerlink" title="2.各泛型约束"></a>2.各泛型约束</h3><ol>
<li>值类型约束</li>
</ol>
<pre><code class="c#">class Test1&lt;T&gt; where T:struct
&#123;
        public T value;
        public void TestFun&lt;K&gt;(K k) where K:struct
        &#123;

        &#125;
&#125;
</code></pre>
<ol start="2">
<li>引用类型约束</li>
</ol>
<pre><code class="c#">class Test2&lt;T&gt; where T:class
&#123;
        public T value;
&#125;
</code></pre>
<ol start="3">
<li>公共无参构造函数约束</li>
</ol>
<pre><code class="c#">class Test3&lt;T&gt; where T:new()    
//即T所代表的类必须具有无参构造函数，而且不能是抽象类，注意值类型都有无参构造可以传入
&#123;
        public T value;
        public void TestFun&lt;K&gt;(K k) where K:new()
        &#123;

        &#125;
&#125;
</code></pre>
<ol start="4">
<li>某个类本身或其派生类</li>
</ol>
<pre><code class="c#">class Test4&lt;T&gt; where T:Test1                //Test1的父类不行
&#123;
        
&#125;
</code></pre>
<ol start="5">
<li>某个接口的派生类型</li>
</ol>
<pre><code class="c#">interface IFly
&#123;

&#125;
class Test5&lt;T&gt; where T:IFly
&#123;

&#125;
</code></pre>
<ol start="6">
<li>另一个泛型类型本身或其派生</li>
</ol>
<pre><code class="c#">class Test6&lt;T, U&gt; where T:U                //要不T与U是相同的，要不T是U的派生类
&#123;
        public void TestFun&lt;K, V&gt;(K k) where K:V
        &#123;
                
        &#125;
&#125;
</code></pre>
<h3 id="3-约束的组合使用"><a href="#3-约束的组合使用" class="headerlink" title="3.约束的组合使用"></a>3.约束的组合使用</h3><pre><code class="c#">class Test7&lt;T&gt; where T: class, new()          //表示这个泛型只能是有公共无参构成函数的引用类型
&#123;

&#125;
</code></pre>
<h3 id="4-多个泛型有约束"><a href="#4-多个泛型有约束" class="headerlink" title="4.多个泛型有约束"></a>4.多个泛型有约束</h3><pre><code class="c#">class Test8&lt;T, K&gt; where T:class where K:struct
&#123;

&#125;
</code></pre>
<h3 id="5-泛型单例模式基类（单例模式可直接继承，可增加代码重用，减少代码量）"><a href="#5-泛型单例模式基类（单例模式可直接继承，可增加代码重用，减少代码量）" class="headerlink" title="5.泛型单例模式基类（单例模式可直接继承，可增加代码重用，减少代码量）"></a>5.泛型单例模式基类（单例模式可直接继承，可增加代码重用，减少代码量）</h3><pre><code class="c#">class SingleBase&lt;T&gt; where T : new()
&#123;
        private static T instance = new T();
        public static T Instance
        &#123;
            get
            &#123;
                return instance;
            &#125;
        &#125;
&#125;

class Test : SingleBase&lt;Test&gt; 
&#123;
        public void TestFun()
        &#123;

        &#125;
&#125;
</code></pre>
<h1 id="知识点三-常用泛型数据结构类"><a href="#知识点三-常用泛型数据结构类" class="headerlink" title="知识点三 常用泛型数据结构类"></a>知识点三 常用泛型数据结构类</h1><h2 id="一、List"><a href="#一、List" class="headerlink" title="一、List"></a>一、List</h2><h3 id="1-List本质"><a href="#1-List本质" class="headerlink" title="1.List本质"></a>1.List本质</h3><p>List是一个c#为我们封装好的类<br>它本质是一个可变类型的泛型数组<br>List类帮助我们实现了很多方法<br>比如泛型数组的增删查改</p>
<h3 id="2-申明-3"><a href="#2-申明-3" class="headerlink" title="2.申明"></a>2.申明</h3><p>需要引用命名空间</p>
<pre><code class="c#">using System.Collections.Generic
List&lt;int&gt; list = new List&lt;int&gt;();
</code></pre>
<h3 id="3-增删查改-2"><a href="#3-增删查改-2" class="headerlink" title="3.增删查改"></a>3.增删查改</h3><ol>
<li>增</li>
</ol>
<pre><code class="c#">list.Add(1);
list.Add(2);
list.Add(3);
list.Add(4);
</code></pre>
<ol start="2">
<li>范围增加</li>
</ol>
<pre><code class="c#">List&lt;int&gt; list2 = new List&lt;int&gt;();
list2.Add(123);
list.AddRange(list2);
</code></pre>
<ol start="3">
<li>插入</li>
</ol>
<pre><code class="c#">list.Insert(0, 999);
</code></pre>
<ol start="4">
<li>删</li>
</ol>
<pre><code class="c#">//a.移除指定类型
list.Remove(1);
//b.移除指定位置的元素
list.RemoveAt(0);
//c.清空
list.Clear();
</code></pre>
<ol start="5">
<li>查</li>
</ol>
<pre><code class="c#">//a.得到指定位置的元素
Console.Write(list[0]);
//b.查看元素是否存在
if( list.Contains(1) )                //返回bool值
&#123;

&#125;
//c.正向查找元素
Console.Write( list.IndexOf(1))        //正向查找元素，若找不到返回-1
//d.反向查找元素
Console,Write( list.LastIndexOf(1) )        //反向查找元素，若不到返回-1
</code></pre>
<ol start="6">
<li>改</li>
</ol>
<pre><code class="c#">list[0] = 10;
</code></pre>
<h3 id="4-遍历-3"><a href="#4-遍历-3" class="headerlink" title="4.遍历"></a>4.遍历</h3><pre><code class="c#">//长度
Console.Write( list.Count);
//容量
Console.Write( list.Capacity );
//遍历
for(int i = 0; i &lt; list.Count; i++)
&#123;
        
&#125;
foreach( int item in list)
&#123;
    Console.Write(item);
&#125;
</code></pre>
<h2 id="二、Dictionary"><a href="#二、Dictionary" class="headerlink" title="二、Dictionary"></a>二、Dictionary</h2><h3 id="1-Dictionary的本质"><a href="#1-Dictionary的本质" class="headerlink" title="1.Dictionary的本质"></a>1.Dictionary的本质</h3><p>可以将Dictionary理解为 拥有泛型的Hashtable<br>它也是基于键的哈希代码组织起来的 键&#x2F;值对<br>键值对类型从Hashtable的object变为了可以自己定制的泛型</p>
<h3 id="2-申明-4"><a href="#2-申明-4" class="headerlink" title="2.申明"></a>2.申明</h3><p>先引用命名空间</p>
<pre><code class="c#">using System.Conllections.Generic
Dictionary&lt;int, string&gt; dictionary = new Dictionary&lt;int, string&gt;();
</code></pre>
<h3 id="3-增删查改-3"><a href="#3-增删查改-3" class="headerlink" title="3.增删查改"></a>3.增删查改</h3><ol>
<li>增</li>
</ol>
<pre><code class="c#">//注意：不能出现相同的键
dictionary.Add(1, &quot;123&quot;);
dictionary.Add(2, &quot;222&quot;);
dictionary.Add(3, &quot;222&quot;);
</code></pre>
<ol start="2">
<li>删</li>
</ol>
<pre><code class="c#">//a.只能通过键删除，删除不存在的键，没反应
dictionary.Remove(1);                //删除1键对应的键值对
//b.清空
dictionary.Clear();
</code></pre>
<ol start="3">
<li>查</li>
</ol>
<pre><code class="c#">//a.通过键查看值，找不到会报错
Console.Write(dictionary[2]);
//b.查看是否存在
//根据键检测
if( dictionary.ContainsKey(1) )                                        //返回一个bool
&#123;

&#125;
//根据值检测
if(dictionary.Console.Value(&quot;123&quot;))                        //返回一个bool
&#123;
                
&#125;
</code></pre>
<ol start="4">
<li>改</li>
</ol>
<pre><code class="c#">dictionary[1] = &quot;789&quot;;
</code></pre>
<h3 id="4-遍历-4"><a href="#4-遍历-4" class="headerlink" title="4.遍历"></a>4.遍历</h3><pre><code class="c#">//获取长度  dictionary.Count
//a.遍历所有键
foreach(int item in dictionart.Keys)
&#123;
        Console.WriteLine(item);
        Console.WriteLine(dictionary[item]);
&#125;
//b.遍历所有值
foreach(string item in dictionary.Values)                //hashtable无法通过值找键
&#123;
        Console,WriteLine(item);
&#125;
//c.键值对一起遍历
foreach(KeyValuePair&lt;int, string&gt; item int dictionary)
&#123;
        Console.WriteLine(item.Key);
        Console.WriteLine(item.Value);
&#125;
</code></pre>
<h2 id="三、顺序存储和链式存储"><a href="#三、顺序存储和链式存储" class="headerlink" title="三、顺序存储和链式存储"></a>三、顺序存储和链式存储</h2><h3 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1.数据结构"></a>1.数据结构</h3><p>数据结构是计算机存储、组织数据的方式（规则）<br>数据结构是指相互之间存在一种或多种特定关系的数据元素集合<br>比如自定义一个 类 也可以称为一种数据结构 自己定义的数据组合规则</p>
<p>不用把数据结构想的太复杂<br>简单理解就是 人定义的 存储数据 和 表示数据之间关系 的规则</p>
<p>常用的数据结构<br>数组、栈、队列、链表、树、图、堆、散列表</p>
<h3 id="2-线性表"><a href="#2-线性表" class="headerlink" title="2.线性表"></a>2.线性表</h3><p>线性表是一种数据结构，是由n个具有相同特性的数据元素的有限序列<br>比如数组、ArrayList、Stack、Queue、链表等</p>
<p>顺序存储和链式存储是数据结构中的两种存储结构</p>
<h3 id="3-顺序存储"><a href="#3-顺序存储" class="headerlink" title="3.顺序存储"></a>3.顺序存储</h3><p>数组、Stack、Queue、List、ArraryList ——  顺序存储<br>只是 数组、Stack、Queue的 组织规则不同而已<br>顺序存储：<br>用一组地址连续的存储单元依次存储线性表的各个数据元素</p>
<h3 id="4-链式存储"><a href="#4-链式存储" class="headerlink" title="4.链式存储"></a>4.链式存储</h3><p>单向链表、双向链表、循环链表 —— 链式存储<br>链式存储（链接存储）：<br>用一组任意的存储单元存储线性表中的各个数据元素<br>单向链表：O → O →O        （任意的存储单元）<br>双向链表：O &lt;—&gt;O &lt;—&gt;O         （任意的存储单元）</p>
<h3 id="5-自己实现一个最简单的单向链表"><a href="#5-自己实现一个最简单的单向链表" class="headerlink" title="5.自己实现一个最简单的单向链表"></a>5.自己实现一个最简单的单向链表</h3><pre><code class="c#">//单向链表结点
class LinkedNode&lt;T&gt;
&#123;
    public T value;
    public LinkedNode&lt;T&gt; nextNode;                //存储下一个元素是谁 相当于结点
    public LinkedNode(T value)
    &#123;
        this.value = value;
    &#125;
&#125;
//单向链表类，管理链表的增加、删减等
class LinkedList&lt;T&gt;
&#123;
    public LinkedNode&lt;T&gt; head;
    public LinkedNode&lt;T&gt; last;
        
    public void Add(T value)
    &#123;
        LinkedNode&lt;T&gt; node = new LinkedNode&lt;T&gt;(value);
        if(head == null)
        &#123;
            head = node;
            last = node;
        &#125;
        else
        &#123;
            last.nextNode = node;
            last = node;
        &#125;
    &#125;

    public void Remove(T value)
    &#123;
        if( head == null )
        &#123;
            return;
        &#125;
        if( head.value.Equals(value) )
        &#123;
            head = head.nextNode;
            //如果头结点 被移除 发现头结点变空，那么尾结点也要变空
            if(head == null)
            &#123;
                last = null;
            &#125;
                return;
        &#125;
        //循环遍历，查找
        LinkedNode&lt;T&gt; node = head;
        whlie(node.nextNode != null)
        &#123;
            if( node.nextNode.value.Equals(value) )
            &#123;
                node.nextNode = node.nextNode.nextNode;
                break;
            &#125;        
                node = node.nextNode;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="6-顺序存储和链式存储的优缺点"><a href="#6-顺序存储和链式存储的优缺点" class="headerlink" title="6.顺序存储和链式存储的优缺点"></a>6.顺序存储和链式存储的优缺点</h3><p>从增删查改的角度<br>增：链式存储 计算上 优于顺序存储 （中间插入时链式存储不用像顺序存储一样移动位置）<br>删：链式存储 计算上 优于顺序存储（中间删除时链式不用像顺序一样移动位置）<br>查：顺序存储 使用上 优于链式存储（数组可以直接通过下标来得到元素，链式需要遍历）<br>改：顺序存储 使用上 优于链式存储（数组可以直接通过下标来得到元素，链式需要遍历）</p>
<h2 id="四、LinkedList"><a href="#四、LinkedList" class="headerlink" title="四、LinkedList"></a>四、LinkedList</h2><h3 id="1-LinkedList"><a href="#1-LinkedList" class="headerlink" title="1.LinkedList"></a>1.LinkedList</h3><p>LinkedList是一个C#为我们封装好的类<br>它的本质是一个可变类型的泛型双向链表</p>
<h3 id="2-申明-5"><a href="#2-申明-5" class="headerlink" title="2.申明"></a>2.申明</h3><p>需要引用命名空间</p>
<pre><code class="c#">using System.Collections.Generic
LinkedList&lt;int&gt; linkedList = new LinkedList&lt;int&gt;();
</code></pre>
<p>链表对象 需要掌握两个类<br>一个是链表本身，一个是链表结点类LinkedListNode</p>
<h3 id="3-增删查改-4"><a href="#3-增删查改-4" class="headerlink" title="3.增删查改"></a>3.增删查改</h3><ol>
<li>增</li>
</ol>
<pre><code class="c#">//a.在链表尾部添加元素
linkedList.AddLast(10);

//b.在链表头部添加
linkedList.AddFirst(20);

//c.在某个节点之后增加节点
//要指定节点，要先得到一个节点
LinkedListNode&lt;int&gt; n = linkedList.Find(20);
linkedList.AddAfter(n, 15);        //往n节点后面插入一个节点，存储值为15

//d.在某个节点之前增加一个节点
linkdeList.AddBefore(n, 14);        //往n节点前插入一个节点，存储值为14
</code></pre>
<ol start="2">
<li>删</li>
</ol>
<pre><code class="c#">//a.移除头节点
linkedList.RemoveFirst();

//b.移除尾节点
linkedList.RemoveLast();

//c.移除指定节点
linkedList.Remove(20);

//d.清空
linkedList.Clear();
</code></pre>
<ol start="3">
<li>查</li>
</ol>
<pre><code class="c#">//a.头节点
LinkedListNode&lt;int&gt; first = linkdList.First;

//b.尾结点
LinkedListNode&lt;int&gt; last= linkdList.Last;

//c.找到指定值节点
LinkedListNode&lt;int&gt; node = linkedList.Find(10);   
//括号中填一个节点存储的值，若找不到返回null

//d.判断是否存在
if( linkedList.Contains(1) )
&#123;

&#125;
</code></pre>
<ol start="4">
<li>改</li>
</ol>
<pre><code class="c#">//先得到节点，在改变其中的值
linkedList.First.Value = 16;
</code></pre>
<p>4.遍历</p>
<pre><code class="c#">//a.foreach遍历
foreach( int item in linkedList )
&#123;
        Console.WriteLine(item);                        //可以直接打印值，而不是去节点
&#125;

//b.通过节点遍历
//从头到尾
LinkedListNode&lt;int&gt; nowNode = linkedList.First;
while( nowNode != null )
&#123;
        Console.WriteLine(nowNode.Value);
        nowNode = nowNode.Next;
&#125;

//从尾到头
LinkedListNode&lt;int&gt; nowNode = linkedList.Last;
while( nowNode != null )
&#123;
        Console.WriteLine(nowNode.Value);
        nowNode = nowNode.Previous;
&#125;
</code></pre>
<h2 id="五、泛型栈和队列"><a href="#五、泛型栈和队列" class="headerlink" title="五、泛型栈和队列"></a>五、泛型栈和队列</h2><h3 id="1-回顾数据容器"><a href="#1-回顾数据容器" class="headerlink" title="1.回顾数据容器"></a>1.回顾数据容器</h3><ol>
<li><p>变量<br>int<br>uint<br>string<br>float</p>
</li>
<li><p>复杂数据容器<br>枚举<br>结构体<br>数组<br>类</p>
</li>
<li><p>数据集合<br>using System.Collections;</p>
</li>
</ol>
<p>ArraryList                object数据列表<br>Stack                      栈        <br>Queue                    队列<br>Hashtable               哈希表<br>缺点：存在装箱拆箱</p>
<ol start="4">
<li>泛型数据集合<br>using System.Collections.Generic;</li>
</ol>
<p>List                       列表      泛型列表<br>Dictionary             字典     泛型哈希表<br>LinkedList             双向链表<br>Stack                   泛型栈<br>Queue                  泛型队列</p>
<h3 id="2-泛型栈和泛型队列"><a href="#2-泛型栈和泛型队列" class="headerlink" title="2.泛型栈和泛型队列"></a>2.泛型栈和泛型队列</h3><pre><code class="c#">//先引用命名空间
using Sysytem.Collections.Generic
//使用上，和之前Stack和Queue一样

Stack&lt;int&gt; stack = new Stack&lt;int&gt;();
Queue&lt;int&gt; queue= new Queue&lt;int&gt;();
</code></pre>
<h1 id="知识点四-委托和事件"><a href="#知识点四-委托和事件" class="headerlink" title="知识点四 委托和事件"></a>知识点四 委托和事件</h1><h2 id="一、委托"><a href="#一、委托" class="headerlink" title="一、委托"></a>一、委托</h2><h3 id="1-委托是什么"><a href="#1-委托是什么" class="headerlink" title="1.委托是什么"></a>1.委托是什么</h3><p>委托是 函数（方法）的容器<br>可以理解为表示函数（方法）的变量类型<br>用来 存储 传递 函数（方法）<br>委托的本质是一个类，用来定义函数（方法）的类型（返回值和参数的类型）<br>不同的函数（方法）必须对应和各自“格式”一致的委托</p>
<h3 id="2-基本语法"><a href="#2-基本语法" class="headerlink" title="2.基本语法"></a>2.基本语法</h3><p>关键字：delegate<br>语法：访问修饰符 delegate 返回值 委托名(参数列表)</p>
<p>写在哪里？<br>可以申明在namespace和class语句块中<br>更多申明在namespace中<br>简单记忆就是，在函数申明的返回值前加一个delegate关键字</p>
<h3 id="3-定义自定义委托"><a href="#3-定义自定义委托" class="headerlink" title="3.定义自定义委托"></a>3.定义自定义委托</h3><p>访问修饰默认，不写为public，在别的命名空间中也能使用<br>private，其他命名空间就不能使用了<br> 一般用public<br>委托不存在重载，不能同名（同一语句块中）</p>
<p>申明了一个可以用来存储无参无返回值的容器，只是定义了规则，并无使用</p>
<pre><code class="c#">public delegate void MyFun();
</code></pre>
<p>表示用来装载或传递，返回值为int，有一个int参数的函数的委托容器规则</p>
<pre><code class="c#">public delegate int MyFun2(int a);
</code></pre>
<p>委托支持泛型</p>
<pre><code class="c#">public delegate T MyFun3&lt;T&gt;(T t);
</code></pre>
<h3 id="4-使用定义好的委托"><a href="#4-使用定义好的委托" class="headerlink" title="4.使用定义好的委托"></a>4.使用定义好的委托</h3><p>委托变量是函数的容器</p>
<p>委托的基本使用</p>
<pre><code class="c#">static void Fun()
&#123;

&#125;
MyFun f = new MyFun(Fun);               
//传入的函数必须遵守定义好规则，在这里就是无参无返回值的函数，注意不能打括号
f.Invoke();        //直接调用  Fun()  函数

MyFun f2 = Fun;        //另一种申明方法
f2();                            //直接调用 Fun() 函数
Console.WriteLine( f3(1) );                        //假如是有参数，有返回值函数，就和函数使用一样
</code></pre>
<p>委托常在：</p>
<ul>
<li>作为类的成员</li>
<li>作为函数的参数</li>
</ul>
<p>委托的常用</p>
<pre><code class="c#">class Test
&#123;
    public MyFun fun;
    public MyFun fun2;

    public void TestFun( MyFun fun, MyFun2 fun2 )
    &#123;
        this.fun = fun;
        this.fun2 = fun2;
    &#125;
&#125;
</code></pre>
<h3 id="5-委托变量可以存储多个函数（多播委托）"><a href="#5-委托变量可以存储多个函数（多播委托）" class="headerlink" title="5.委托变量可以存储多个函数（多播委托）"></a>5.委托变量可以存储多个函数（多播委托）</h3><pre><code class="c#">1. 增
MyFun ff = Fun();
ff += Fun;
ff();                   //Fun()函数会执行两次
2. 删
ff -= Fun;
3. 清空
ff = null;
</code></pre>
<h3 id="6-系统定义好的委托"><a href="#6-系统定义好的委托" class="headerlink" title="6.系统定义好的委托"></a>6.系统定义好的委托</h3><p>using System;</p>
<ul>
<li>Action  ——无参无返回值委托</li>
<li>Func&lt;变量类型&gt;  ——泛型委托，可填任意类型返回值的委托，返回T，无参</li>
<li>Action&lt;变量类型, ….&gt;  ——泛型委托，可传入任意类型、最多16个参数      </li>
<li>Func&lt;变量类型, ….&gt;    ——有参数有返回值，返回值类型是泛型的最后一个</li>
</ul>
<h2 id="二、事件"><a href="#二、事件" class="headerlink" title="二、事件"></a>二、事件</h2><h3 id="1-事件是什么"><a href="#1-事件是什么" class="headerlink" title="1.事件是什么"></a>1.事件是什么</h3><p>事件是基于委托的存在<br>事件是委托的安全包裹<br>让委托的使用更具有安全性<br>事件 是一种特殊的变量类型</p>
<h3 id="2-事件的使用"><a href="#2-事件的使用" class="headerlink" title="2.事件的使用"></a>2.事件的使用</h3><p>申明语法：<br>访问修饰符 event 委托类型 事件名;<br>事件的使用：</p>
<ul>
<li>事件是作为 成员变量 存在于 类 中</li>
<li>委托怎么用 事件就怎么用<br>事件相对于委托的区别：</li>
<li>不能在类外部 赋值</li>
<li>不能在类外部 调用</li>
<li>但可以在外部加减<br>注意：<br>它只能作为成员存在于类和接口以及结构体中<br>事件不能作为临时变量，在函数中使用</li>
</ul>
<pre><code class="c#">class Test
&#123;
    public Action myFun;
    public event Actiong myEvent;

    public Test()
    &#123;
        //事件和委托一模一样，只是有些细微区别，增加、减少和置空也一样，
        myFun = TestFun;
        myEvent = TestFun;
    &#125;
    public void TestFun()
    &#123;
                
    &#125;
&#125;
</code></pre>
<h3 id="3-为什么有事件"><a href="#3-为什么有事件" class="headerlink" title="3.为什么有事件"></a>3.为什么有事件</h3><ul>
<li>防止外部随意置空委托</li>
<li>防止外部随意调用委托</li>
<li>事件相当于对委托进行了封装，让其更安全</li>
</ul>
<h2 id="三、匿名函数"><a href="#三、匿名函数" class="headerlink" title="三、匿名函数"></a>三、匿名函数</h2><h3 id="1-什么是匿名函数"><a href="#1-什么是匿名函数" class="headerlink" title="1.什么是匿名函数"></a>1.什么是匿名函数</h3><p>顾明思义，就是没有名字的函数<br>匿名函数的使用主要是配合委托和事件进行使用<br>脱离委托和事件，匿名函数是不会使用的</p>
<h3 id="2-基本语法-1"><a href="#2-基本语法-1" class="headerlink" title="2.基本语法"></a>2.基本语法</h3><p>delegate (参数列表)<br>{<br>        &#x2F;&#x2F;函数逻辑<br>};<br>何时使用？</p>
<ul>
<li>函数中传递委托参数时</li>
<li>委托和事件赋值时</li>
</ul>
<h3 id="3-使用"><a href="#3-使用" class="headerlink" title="3.使用"></a>3.使用</h3><ol>
<li>无参无返回值</li>
</ol>
<pre><code class="c#">//此时只是申明，不是调用，若要调用，应该调用委托
Action a = delegate()
&#123;
    Console.WriteLine(&quot;申明一个匿名函数&quot;);
&#125;;
a();    //调用
</code></pre>
<ol start="2">
<li>有参无返回值</li>
</ol>
<pre><code class="c#">Action&lt;int, string&gt; b = delegate(int a, string b)
&#123;
    Console.WriteLine(a);
&#125;;
b(100, 123);
</code></pre>
<ol start="3">
<li>有返回值</li>
</ol>
<pre><code class="c#">Func&lt;string&gt; c = delegate ()
&#123;
        return &quot;123456&quot;;
&#125;;
</code></pre>
<ol start="4">
<li>一般情况会作为函数参数传递 或者 作为函数返回值</li>
</ol>
<pre><code class="c#">class Test
&#123;
    public Action action;
    //a.参数
    public void Dosomthing(int a, Action fun)
    &#123;
        Console.WriteLine(a);
        fun();
    &#125;  
    //b.返回值
    public Action GetFun()
    &#123;
        return delegate()
        &#123;
            Console.WriteLine(&quot;作为返回值传递&quot;);
        &#125;;
    &#125;
&#125;
Test t = new Test();
//a.作为参数传递
t.Dosomthing(100, delegate()
&#123;
        Console.Write(&quot;随参数传递的匿名函数&quot;)
&#125;);

//b.返回值
Action ac = t.GetFun();
ac();
//或者
t.GetFun()();
</code></pre>
<h3 id="4-匿名函数的缺点"><a href="#4-匿名函数的缺点" class="headerlink" title="4.匿名函数的缺点"></a>4.匿名函数的缺点</h3><p>添加到委托或事件容器中后 不记录 无法单独移除<br>因为匿名函数没有名字，没有办法指定移除某一个匿名函数</p>
<h2 id="四、Lambad表达式"><a href="#四、Lambad表达式" class="headerlink" title="四、Lambad表达式"></a>四、Lambad表达式</h2><h3 id="1-什么是lambad表达式"><a href="#1-什么是lambad表达式" class="headerlink" title="1.什么是lambad表达式"></a>1.什么是lambad表达式</h3><p>可以将lambad表达式，理解为匿名函数的简写<br>它除了写法不同以为<br>使用上和匿名函数一样<br>都是和委托或事件 配合使用</p>
<h3 id="2-lambad表达式语法"><a href="#2-lambad表达式语法" class="headerlink" title="2.lambad表达式语法"></a>2.lambad表达式语法</h3><pre><code class="c#">(参数列表)=&gt;
&#123;
    //函数体
&#125;;
</code></pre>
<h3 id="3-使用-1"><a href="#3-使用-1" class="headerlink" title="3.使用"></a>3.使用</h3><p>与匿名函数相同</p>
<ol>
<li>无参无返回值</li>
</ol>
<pre><code class="c#">Action a = ()=&gt;
&#123;
    Console.WriteLine();
&#125;;
a();
</code></pre>
<ol start="2">
<li>有参</li>
</ol>
<pre><code class="c#">Action&lt;int&gt; a2 = (int value)=&gt;
&#123;

&#125;;
a2(10);
</code></pre>
<ol start="3">
<li>参数类型可省略，参数类型与委托或事件一致</li>
</ol>
<pre><code class="c#">Action&lt;int&gt; a3 = (value)=&gt;
&#123;

&#125;;
</code></pre>
<ol start="4">
<li>有返回值</li>
</ol>
<pre><code class="c#">Func&lt;string, int&gt; f = (str)
&#123;
    return 4;
&#125;;
//其他传参使用等都和匿名函数一样
//缺点也和匿名函数一样
</code></pre>
<h3 id="4-闭包"><a href="#4-闭包" class="headerlink" title="4.闭包"></a>4.闭包</h3><p>内层函数可以引用包含在它外层的函数的变量<br>即使外层函数的执行已经终止<br>注意：<br>该变量提供的值并非变量创建时的值，而是在父函数范围内的最终值</p>
<pre><code class="c#">class Test
&#123;
    public event Action action;
        
    public Test()
    &#123;
        int value = 10;
        //这里形成的闭包
        //因为 当构造函数执行完毕时，其中申明的临时变量value的生命周期被改变了
        action = ()=&gt;
        &#123;
            Console.WriteLine(Value);      
        &#125;;
    &#125;  

    for(int i = 0; i &lt; 10; i++)
    &#123;
        action += ()=&gt;
        &#123;
            Console.WriteLine( i );
        &#125;
    &#125;
    //会打印十次10

    for(int i = 0; i &lt; 10; i++)
    &#123;
        action += ()=&gt;
        &#123;
            int index = i;   //每次都会声明一个新index（此Index非彼index）
            Console.WriteLine( index );
        &#125;
    &#125;
    //会打印0~9
&#125;
</code></pre>
<h1 id="知识点五-List排序"><a href="#知识点五-List排序" class="headerlink" title="知识点五 List排序"></a>知识点五 List排序</h1><ol>
<li>List 自带排序方法</li>
</ol>
<pre><code class="c#">List&lt;int&gt; list = new List&lt;int&gt;();
list.Add(3);
list.Add(2);
list.Add(6);
list.Add(1);
list.Add(4);
list.Add(5);
list.Sort();                        //升序排序方法
</code></pre>
<ol start="2">
<li>自定义类的排序</li>
</ol>
<pre><code class="c#">class Item : IComparable&lt;Item&gt;        //继承排序接口，实现排序
&#123;
    public int money;
    public Item(int money)
    &#123;
        this.money = money;
    &#125;

    //写排序逻辑
    public int CompareTo(Item other)
    &#123;
        //返回值含义
        //小于0：放在传入对象的前面
        //等于0：位置不变
        //大于0：放在传入对象的后面

        if( this.money &gt; other.money )
        &#123;
            return 1;        //向右移动
        &#125;
        else if( this.money = other.money )
        &#123;
            return 0;
        &#125;
        else if( this.money &lt; other.money )
        &#123;
            return -1;        //向左移动
        &#125;
    &#125;
&#125;

List&lt;Item&gt; itemList = new List&lt;Item&gt;();
itemList.Add(new Item(10));
itemList.Add(new Item(50));
itemList.Add(new Item(90));
itemList.Add(new Item(100));
itemList.Add(new Item(40));
itemList.Add(new Item(60));
itemList.Sort();
</code></pre>
<p>3.通过委托函数进行排序</p>
<pre><code class="c#">class ShopItem
&#123;
    public int id;
    public ShopItem(int id)
    &#123;
        this.id = id
    &#125;
&#125;
List&lt;ShopItem&gt; shopItems = new List&lt;ShopItem&gt;();
shopItems.Add(new ShopItem(10));
shopItems.Add(new ShopItem(80));
shopItems.Add(new ShopItem(50));
shopItems.Add(new ShopItem(16));
shopItems.Add(new ShopItem(70));
shopItems.Add(new ShopItem(30));
shopItems.Add(new ShopItem(40));

static int SortShopItem(ShopItem a, ShopItem b)
&#123;
    //传入的两个对象，为列表中的两个对象
    //进行两两比较，用左边的(a)和右边的(b)进行比较
    //以下是升序排序的逻辑
    if( a.id &gt; b.id)
    &#123;
        return 1;
    &#125;
    if( a.id &lt; b.id )
    &#123;
        return -1;
    &#125;
&#125;

shopItems.Sout(SortShopItem);        //排序方法

用lambad表达式配合三目运算符  以上一行代码可搞定
shopItems.Sout( (a, b)=&gt;
&#123;
    return a.id &gt; b.id ? 1 : -1;
&#125;);
</code></pre>
<h1 id="知识点六-协变逆变"><a href="#知识点六-协变逆变" class="headerlink" title="知识点六 协变逆变"></a>知识点六 协变逆变</h1><ol>
<li>什么是协变逆变<br>协变：<br>和谐的变化，自然的变化<br>因为里氏替换原则，父类可以装子类<br>所以子类变父类<br>比如 string 变成 object<br>感受是和谐的</li>
</ol>
<p>逆变：<br>逆常规的变化，不正常的变化<br>因为 里氏替换原则 父类可以装子类 但是子类不能装父类<br>所以 父类变子类<br>比如 object 变成 string<br>感受是不和谐的</p>
<p>协变和逆变是用来修饰泛型的<br>协变：out<br>逆变：in<br>用于泛型中 修饰 泛型字母的<br>只有泛型接口和泛型委托能使用</p>
<ol start="2">
<li>作用<br>a.返回值 和 参数<br>用out修饰的泛型 只能作为返回值<br>delegate T TestOut<out T>();<br>用in修饰的泛型 只能作为参数<br>delegate void TestIn<in T>(T v);</li>
</ol>
<p>b.结合里氏替换原则解释</p>
<pre><code class="c#">class Father
&#123;

&#125;
class Son : Father
&#123;

&#125;

//协变    父亲总是能被子类替换
//Son ——&gt; Father
TestOut&lt;Son&gt; os = ()=&gt;
&#123;
    return new Son();
&#125;;
TestOut&lt;Father&gt; of = os;    //delegate T TestOut&lt;out T&gt;(); 若这里不加out，是会报错的  
Father f = of();            //实际上，返回的是os里面装的函数，是Son类

//逆变  父亲总是能被子类替换
//看起来是 father ——&gt; son 明明是传父类，但是你装子类，不和谐
TestIn&lt;Father&gt; iF = (value)=&gt;
&#123;
      
&#125;
TestIn&lt;Son&gt; iS = iF;    //delegate void TestIn&lt;in T&gt;(T v);若不加in，无法声明
iS(new Father());       //会报错
iS(new Son());          //不会报错，实际上调用iF，参数是Father类
</code></pre>
<h1 id="知识点七-多线程"><a href="#知识点七-多线程" class="headerlink" title="知识点七 多线程"></a>知识点七 多线程</h1><ol>
<li><p>进程<br>进程（Process）是计算机中的程序关于某数据集合的一次运行活动<br>是系统进行资源分配和调度的基本单位，是操作系统结构的基础<br>简单来说：打开一个应用程序就是在操作系统中开启了一个进程<br>进程之间相互独立运行，互不干扰<br>进程之间也可以相互访问，操作</p>
</li>
<li><p>线程<br>操作系统能够进行运算调度的最小单位<br>它被包含到进程中，是进程中的实际运作单位<br>一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程<br>我们目前写的程序都在主线程中</p>
</li>
</ol>
<p>简单来讲，就是代码从上到下运行的一条“管道”</p>
<ol start="3">
<li><p>什么是多线程<br>我们可以通过代码，开启新的线程<br>可以同时运行代码的多条“管道”，就叫多线程</p>
</li>
<li><p>语法相关<br>线程类  Thread<br>需要引用命名空间 using System.Threading</p>
</li>
</ol>
<pre><code class="c#">//a.申明一个新的线程
//注意 线程执行的代码需要封装到一个函数中
//先声明一个函数
static void NewThreadLogic()
&#123;
        //新开线程，执行的代码逻辑，在该函数语句块中
&#125;
Thread t = new Thread(NewThreadLogic);        //新线程将要执行的代码逻辑被封装到该函数中

//b.启动线程
//前台线程
t.Start();

//c.设置为后台线程
/*
当前台线程都结束时，整个程序都结束了，即使有后台线程正在运行
后台线程不会防止应用程序的进程被终止
如果不设置为后台线程，可能导致进程无法正常关闭
如果主线程执行完毕结束了，那后台线程也会被强制结束
*/
t.IsBackground = true;  //设置为后台线程

//d.关闭释放一个线程
/*
如果开启的线程中不是死循环，是能够结束的逻辑，那么，不用刻意关闭它
如果是死循环，要关闭它，有两种方式
*/
//a.死循环中的循环条件bool标识

static bool isRunning = true;
static void NewThreadLogic()
&#123;
    while(isRunning )
    &#123;
                
    &#125;
&#125;       
isRunning = false;

//b.通过线程提供的方法（注意在.Net core版本中无法中止，会报错）
t.Abort();
t = null;        //置空释放，变成垃圾，被回收
</code></pre>
<ol start="5">
<li>线程休眠</li>
</ol>
<pre><code class="c#">Thread.Sleep(传入毫秒);        //在哪个线程内执行，就休眠哪个线程，休眠几毫秒
</code></pre>
<ol start="6">
<li>线程间共享数据（非常重要）<br>多个线程使用的内存是共享的，都属于该应用程序（进程）<br>所以要注意，当多线程，同时操作同一片内存区域时可能会出错<br>可以通过加锁形式避免问题，加锁会影响线程的效率</li>
</ol>
<p>lock关键字<br>当我们在多个线程中想要访问同样的东西，进行逻辑处理时<br>为了避免不必要的逻辑顺序执行错误<br>使用lock关键字<br>lock(引用类型)<br>{<br>    &#x2F;&#x2F;代码逻辑<br>}</p>
<p>例如</p>
<pre><code class="c#">static object obj = new object();
某个线程中：
while(true)
&#123;
    //先检测obj有无上锁，若上锁则不执行，若不上锁则开始执行内部的代码逻辑，并上锁obj
    lock(obj)
    &#123;
        //代码逻辑
    &#125;
    //当执行完其中的代码逻辑就会解锁obj
&#125;
另一个线程中
while(true)
&#123;
    //先检测obj有无上锁，若上锁则不执行，若不上锁则开始执行内部的代码逻辑，并上锁obj
    lock(obj)
    &#123;
        //代码逻辑
    &#125;
    //当执行完其中的代码逻辑就会解锁obj
&#125;
</code></pre>
<ol start="7">
<li>多线程对于我们的意义<br>可以用多线程专门处理一些复杂耗时的逻辑（计算）<br>比如 寻路、网络通信等</li>
</ol>
<h1 id="知识点八-预处理器指令"><a href="#知识点八-预处理器指令" class="headerlink" title="知识点八 预处理器指令"></a>知识点八 预处理器指令</h1><h2 id="一、什么是编译器"><a href="#一、什么是编译器" class="headerlink" title="一、什么是编译器"></a>一、什么是编译器</h2><p>编译器是一种翻译程序<br>它用于将源语言程序翻译为目标语言程序</p>
<p>源语言程序：某种程序设计语言写成的，比如C#、C、C++、Java等语言写的程序<br>目标语言程序：二进制数表示的伪机器代码写的程序</p>
<h2 id="二、什么是预处理器指令"><a href="#二、什么是预处理器指令" class="headerlink" title="二、什么是预处理器指令"></a>二、什么是预处理器指令</h2><p>预处理器指令 指导编译器 在实际编译开始之前对信息进行预处理<br>预处理器指令 都是以#开始<br>预处理器指令不是语句，不以分号 ; 结束<br>目前我们经常用到的 折叠代码块 就是预处理指令</p>
<h2 id="三、常见的预处理指令"><a href="#三、常见的预处理指令" class="headerlink" title="三、常见的预处理指令"></a>三、常见的预处理指令</h2><ol>
<li>#define</li>
</ol>
<p>定义一个符号，类似一个没有值的变量<br>#undef<br>取消#define定义的符号，让其失效<br>两者都是写在脚本文件最前面<br>一般配合 if指令使用 或配合特性<br>#define Unity4   &#x2F;&#x2F;写在所有代码最前面<br>#define Unity5<br>#undef Unity4</p>
<ol start="2">
<li>#if</li>
</ol>
<p>#elif<br>#else<br>#endif<br>和if语句规则一样，一般配合#define定义的符号使用<br>用于告诉编译器进行编译代码的流程控制<br>#if Unity4  &#x2F;&#x2F;如果发现Unity4被定义，则将包裹的内容翻译为二进制<br>    Console.WriteLine(“版本为Unity4”);<br>#elif Unity2017 || Unity2019    &#x2F;&#x2F;如果上面条件不成立，则进入下面这个条件<br>    Console.WriteLine(“版本为Unity2017或Unity2019”);       <br>#warning 这个版本不合法     &#x2F;&#x2F;提示警告，但可以执行<br>#error 这个版本不准执行     &#x2F;&#x2F;提示错误，此时不能运行程序<br>#else<br>    Conole.WriteLine(“其他版本”);                        <br>#endif                                                                &#x2F;&#x2F;使用#if必须写#endif</p>
<ol start="3">
<li>#warning</li>
</ol>
<p>#error<br>告诉编译器<br>是报警告还是报错误<br>一般配合if使用</p>
<h1 id="知识点九-反射"><a href="#知识点九-反射" class="headerlink" title="知识点九 反射"></a>知识点九 反射</h1><h2 id="一、概念和关键类Type"><a href="#一、概念和关键类Type" class="headerlink" title="一、概念和关键类Type"></a>一、概念和关键类Type</h2><h3 id="1-什么是程序集"><a href="#1-什么是程序集" class="headerlink" title="1.什么是程序集"></a>1.什么是程序集</h3><p>程序集是经由编译器编译得到的，供进一步编译执行的那个中间产物<br>在windows系统中，它一般表现为后缀为 .dll（库文件）或 .exe（可执行文件）的格式</p>
<p>简单来讲：<br>程序集就是我们写的一个代码集合，我们现在写的所有代码<br>最终都会被编译器翻译成一个程序集供别人使用<br>比如一个代码库文件（dll）或者一个可执行文件（exe）</p>
<h3 id="2-元数据"><a href="#2-元数据" class="headerlink" title="2.元数据"></a>2.元数据</h3><p>元数据就是用来描述数据的数据<br>这个概念不仅仅用于程序上，在别的领域也有元数据</p>
<p>简单来讲：<br>程序中的类，类中的函数、变量等信息就是 程序的 元数据<br>有关程序以及类型的数据被称为 元数据，它们保存在程序集中</p>
<h3 id="3-反射的概念"><a href="#3-反射的概念" class="headerlink" title="3.反射的概念"></a>3.反射的概念</h3><p>程序正在运行时，可以查看其他程序集或者自身的元数据<br>一个运行的程序查看本身或者其他程序的元数据的行为就叫反射</p>
<p>简单来讲：<br>在程序运行时，通过反射可以得到其他程序集或者自己程序集代码的各种信息<br>类、函数、变量、对象等等，实例化它们，执行它们，操作它们</p>
<h3 id="4-反射的作用"><a href="#4-反射的作用" class="headerlink" title="4.反射的作用"></a>4.反射的作用</h3><p>因为反射可以在程序编译后获得信息，所以它提高了程序的拓展性和灵活性</p>
<ul>
<li>程序运行时得到所有元数据，包括元数据的特性</li>
<li>程序运行时，实例化对象，操作对象</li>
<li>程序运行时创建新对象，用这些对象执行任务</li>
</ul>
<h3 id="5-语法相关"><a href="#5-语法相关" class="headerlink" title="5.语法相关"></a>5.语法相关</h3><pre><code class="c#">//先准备一个类
class Test
&#123;
    private int i = 1;
    public int j = 0;
    public string str = &quot;123&quot;;

    public Test()
    &#123;

    &#125;

    public Test(int i )
    &#123;
        this.i = i;  
    &#125;

    public Test( int i, string str ) : this(i)
    &#123;
        this.str = str;
    &#125;

    public void Speak()
    &#123;
        Console.WriteLine(i);
    &#125;
&#125;
</code></pre>
<ol>
<li>Type(类的信息类)<br>它是反射功能的基础<br>它是访问元数据的主要方式<br>使用 Type 的成员获取有关类型声明的信息<br>有关类型的成员（构造函数、方法、字段、属性和类的事件）</li>
<li>获取Type</li>
</ol>
<pre><code class="c#">//1.万物之父object中的 GetType()可以获取对象的Type
int a = 42;
Type type = a.GetType();    //获取了int32的Type
//2. 通过typeof关键字 传入类名 也可以得到对象的Type
Type type2 = typeof(int);                        //获取了int32的Type
//3.通过类的名字 也可以获取类型
//注意：类名也必须包含命名空间，否则找不到
ype type3 = Type.GetType(&quot;System.Int32&quot;);
//注意：三个type指向的都是同一个堆空间，每个类型的Type都是唯一的
</code></pre>
<ol start="3">
<li>得到类的程序集信息</li>
</ol>
<pre><code class="c#">//通过Type可以得到类型所在的程序集信息
Console.WriteLine(type.Assembly);
</code></pre>
<ol start="4">
<li>获取类中的所有公共成员<br>首先得到Type t &#x3D; typeof(Test);<br>然后得到所有公共成员<br>需要引用命名空间</li>
</ol>
<pre><code class="c#">using System.Reflection;
MemberInfo[] infos = t.GetMembers();
for(int i = 0; i &lt; infos.Length; i++)
&#123;
    Console.WriteLine(infos[ i ]);
&#125;
</code></pre>
<ol start="5">
<li>获取类的公共构造函数并调用</li>
</ol>
<pre><code class="c#">//获取所有构造函数
ConstructorInfo[ ] ctors = t.GetConstructors( );
for(int i = 0; i &lt; ctors.Length; i++)
&#123;
    Console.WriteLine(ctors[i]);
&#125;

//获取其中一个构造函数 并执行
//得到构造函数传入 Type数组 数组中内容按顺序是参数类型
//执行构造函数传入 object数组 表示按顺序传入参数
               
//得到无参构造
ConstructorInfo info = t.GetConstructor( new Type[0] );        //得到无参构造函数
//执行无参构成函数 无参构造没有参数 传null
Test obj = info.Invoke(null) as Test;
                
//得到有参构造
ConstructorInfo info2 = t.GetConstructor(new Type[ ]&#123; typeof(int) &#125;);
obj = info.Invoke(new object[ ] &#123; 2 &#125;) as Test;
Console.WriteLine(obj.str);

ConstructorInfo info3 = t.Constructor(new Type[ ]&#123; typeof(int), typeof()string &#125;);
obj = info.Invoke( new object[ ]&#123; 2, &quot;456&quot; &#125; ) as Test;
</code></pre>
<ol start="6">
<li>获取类中的公共成员变量</li>
</ol>
<pre><code class="c#">//得到所有成员变量
FieldInfo[ ] fieldInfos = t.GetFields();

//得到指定名称的公共成员变量
FieldInfo infoJ = t.GetField(&quot;j&quot;);
FieldInfo infoStr = t.GetField(&quot;str&quot;);

//通过反射获取和设置对象的值
Test test = new Test();
test.j = 99;
test.str = &quot;2222&quot;;
//通过反射 获取对象的某个变量的值
Console.WriteLine( infoJ.GetValue(test) );
Console.WriteLine( infoStr.GetValue(test) );
//通过反射 设置指定对象的某个变量的值
infoJ.SetValue(test, 100);
</code></pre>
<ol start="7">
<li>获得类中的公共成员方法</li>
</ol>
<pre><code class="c#">//通过Type类中的 GetMethod方法 得到类中的方法
//MethodInfo 是方法的反射信息
Type strType = typeof(string);
MethodInfo[] methods = strType.GetMethods();
for(int i = 0; i &lt; methods.Length; i++)
&#123;
    Console.WriteLine(methods[ i ]);
&#125;
//如果存在方法重载 用Type数组表示参数类型
MethodInfo subStr = strType.GetMethod(&quot;Substring&quot;, 
new Type[ ]&#123; typeof(int), typeof(int)  &#125;);
//调用该方法
//注意：如果是静态方法 Invoke中的第一个参数传null即可
string str = &quot;Hello, World!&quot;;
object result = subStr.Invoke(str, new object[ ] &#123; 7, 5 &#125; );
</code></pre>
<ol start="8">
<li>得枚举</li>
</ol>
<pre><code class="c#">GetEnumName();
GetEnumName();
</code></pre>
<ol start="9">
<li>得事件</li>
</ol>
<pre><code class="c#">GetEvent();
GetEvents();
</code></pre>
<ol start="10">
<li>得接口</li>
</ol>
<pre><code class="c#">GetInterface();
GetInterfaces();
</code></pre>
<ol start="11">
<li>得属性</li>
</ol>
<pre><code class="c#">GetProperty();
GetPropertys();
</code></pre>
<h2 id="二、关键类Assembly和Activator"><a href="#二、关键类Assembly和Activator" class="headerlink" title="二、关键类Assembly和Activator"></a>二、关键类Assembly和Activator</h2><h3 id="1-Activator"><a href="#1-Activator" class="headerlink" title="1.Activator"></a>1.Activator</h3><p>用于快速实例化对象的类<br>用于将Type对象快捷实例化为对象<br>先得到Type<br>然后 快速实例化一个对象</p>
<pre><code class="c#">Type test = typeof(Test);
a.无参构造
Test obj = Activator.CreateInstance(test) as Test;

b.有参构造函数
obj = Activator.CreateInstance(test, 99) as Test          //第一个填type类，第二个填构造函数的参数
</code></pre>
<h3 id="2-Assembly"><a href="#2-Assembly" class="headerlink" title="2.Assembly"></a>2.Assembly</h3><p>程序集类<br>主要用来加载其他程序集，加载后<br>才能用Type来使用其他程序集中的信息<br>如果想要使用不是自己程序集中的内容，需要先加载程序集<br>比如 dll文件（库文件）<br>简单的把库文件看成一种代码仓库，它提供给使用者一些可以直接拿来使用的变量、函数或类</p>
<p>三种加载程序集的函数</p>
<pre><code class="c#">//一般用来加载同一文件下的其他程序集
Assembly assembly2 = Assembly.Load(&quot;程序集名称&quot;);

//一般用来加载不在同一文件下的其他程序集
Assembly assembly = Assembly.LoadFrom(&quot;包含程序集清单的文件名或路径&quot;);
Assembly assembly3 = Assembly.LoadFile(&quot;要加载的文件的完全限定路径&quot;);

//先加载一个指定程序集
Assembly assembly = Assembly.LoadFrom(@&quot;包含程序集清单的文件名或路径&quot;);
Type[ ]  types = assembly.GetTypes();
for(int i = 0; i &lt; types.Length; i++)
&#123;
    Console.WriteLine(types[ i ]);
&#125;

//在加载程序集中的一个类对象，之后才能使用反射
Type type类名 = assembly.GetType(&quot;命名空间.类名&quot;);        //填写完整的命名空间和类名
MemberInfo[ ] members = type类名.GetMembers();
for循环打印members，查看有哪些成员可使用
Type moveDic = asembly.GetType(&quot;命名空间.枚举名&quot;);                //获取枚举
FieldInfo right = moveDic.GetField(&quot;枚举名&quot;);
//实例化时，若需要传入枚举，则使用时需要 right.GetValue(null);
</code></pre>
<h3 id="3-类库工程创建"><a href="#3-类库工程创建" class="headerlink" title="3.类库工程创建"></a>3.类库工程创建</h3><p>右键 –&gt; 添加 –&gt; 选择类库文件<br>只写代码逻辑，不能运行</p>
<h1 id="知识点十-特性"><a href="#知识点十-特性" class="headerlink" title="知识点十 特性"></a>知识点十 特性</h1><h2 id="一、特性是什么"><a href="#一、特性是什么" class="headerlink" title="一、特性是什么"></a>一、特性是什么</h2><p>特性是一种允许我们向程序的程序集添加元数据的语言结构<br>它是用于保存程序结构信息的某种特殊类型的类</p>
<p>特性提供功能强大的方法以将声明信息与 C# 代码（类型、方法、属性等）相关联<br>特性与程序实体关联后，即可在运行时使用反射查询特性信息</p>
<p>特性的目的是告诉编译器把程序结构的某组元数据嵌入程序集中<br>它可以放置在几乎所有声明中（类、变量、函数等等申明）</p>
<p>简单来讲：<br>特性本质是个类<br>我们可以利用特性类为元数据添加额外信息<br>比如一个类、成员变量、成员方法等等为他们添加更多的额外信息<br>之后可以通过反射来获取这些额外信息</p>
<h2 id="二、自定义特性"><a href="#二、自定义特性" class="headerlink" title="二、自定义特性"></a>二、自定义特性</h2><p>继承特性基类 Attribute<br>继承 Attribute 就可以自定义一个特性</p>
<pre><code class="c#">class MyCustomAttribute : Attribute     //命名时前面表示含义，后面跟个Attribute
&#123;
    public string info;
        
    public MyCustomAttribute ( string info )
    &#123;
        this.info = info;
    &#125;

    public void TestFun()
    &#123;

    &#125;
&#125;
</code></pre>
<h2 id="三、特性的使用"><a href="#三、特性的使用" class="headerlink" title="三、特性的使用"></a>三、特性的使用</h2><p>基本语法：<br>[ 特性名(参数列表) ]<br>本质上，是在调用特性类的构造函数<br>写在哪里？<br>类、函数、变量上一行，表示他们具有该特性信息</p>
<p>[ MyCustom( “这是一个类” ) ]    &#x2F;&#x2F;后面的Attribute会被默认省略<br>class MyClass<br>{<br>    [ MyCustom( “这是一个函数” ) ]   <br>    public void TestFun()<br>    {</p>
<pre><code>&#125;
</code></pre>
<p>}<br>在主函数中<br>MyClass mc &#x3D; new MyClass();<br>Type t &#x3D; mc.GetType();<br>t &#x3D; typeof( “MyClass” );<br>t &#x3D; Type.GetType(“命名空间.MyClass”);</p>
<pre><code class="c#">//判断是否使用了某个特性
//参数一，代表特性的类型
//参数二，是否搜索继承链（属性和事件忽略此参数）
if( t.IsDefined( typeof(MyCustomAttribute) , false) )           
&#123;
    Console.WriteLine(&quot;该类型应用了MyCustom特性&quot;);
&#125;

//获取Type元数据中的所有特性
object[ ] array = t.GetCustomAttributes(true);      //后面的true表示是否搜索继承链
for(int i = 0; i &lt; array.Length; i++)
&#123;
    if( array[ i ] is MyCustomAttribute )
    &#123;
        Console.WriteLine( (array[ i ]  as MyCustomAttribute).info );
        (array[ i ] as MyCustomAttribute).TestFun();
    &#125;
&#125;
</code></pre>
<h2 id="四、限制自定义特性的使用范围"><a href="#四、限制自定义特性的使用范围" class="headerlink" title="四、限制自定义特性的使用范围"></a>四、限制自定义特性的使用范围</h2><p>通过为特性类 加特性 限制其使用范围</p>
<pre><code class="c#">//AttributeTargets —— 特性能够被用在哪些地方，表示将特性加在类或者结构体前
//AllowMultiple —— 是否允许多个特性实例用在同一个目标上
//Inherited —— 特性是否能被派生类和重写成员继承
[ AttributeUsage( AttributeTargets.Class, AttributeTargets.Struct, AllowMultiple = true, Inherited = true ) ]                        //这是在声明特性前加的特性
class MyCustom2Attribute : Attribute
&#123;
        
&#125;
</code></pre>
<h2 id="五、系统自带特性-——-过时特性"><a href="#五、系统自带特性-——-过时特性" class="headerlink" title="五、系统自带特性 —— 过时特性"></a>五、系统自带特性 —— 过时特性</h2><p>过时特性<br>Obsolete<br>用于提示用户，使用的方法等成员已过时，建议使用新方法<br>一般加在函数前的特性<br>[Obsolete(“该方法已过时”, false) ]<br>&#x2F;&#x2F;参数一，调用过时方法时，提示的内容<br>&#x2F;&#x2F;参数二，true-使用该方法时会报错，false-使用该方法时会警告</p>
<h2 id="六、系统自带特性-——-调用者信息特性"><a href="#六、系统自带特性-——-调用者信息特性" class="headerlink" title="六、系统自带特性 —— 调用者信息特性"></a>六、系统自带特性 —— 调用者信息特性</h2><p>哪个文件调用？<br>CallerFilePath特性<br>哪一行调用？<br>CallerLineNumber特性<br>哪个函数调用？<br>CallerMemberName特性</p>
<p>需要引用命名空间 using System.Runtime.CompilerServices;<br>一般作为函数参数的特性，可以在try catch里的catch使用，异常捕获<br>例如</p>
<pre><code class="c#">public void SpeakCaller(string str, [CallerFilePath]string fileName = &quot;&quot;, 
[CallerLineNumber]int line = 0,[CallerMemberName]string target = &quot;&quot; )
&#123;
    Console.WriteLine(str);
    Console.WriteLine(fileName);        //打印哪个文件调用
    Console.WriteLine(line);                //打印哪一行调用
    Console.WriteLine(target);                //打印在哪个函数调用
&#125;
</code></pre>
<h2 id="七、系统自带特性-——-条件编译特性"><a href="#七、系统自带特性-——-条件编译特性" class="headerlink" title="七、系统自带特性 —— 条件编译特性"></a>七、系统自带特性 —— 条件编译特性</h2><p>条件编译特性<br>Conditional<br>它会和预处理指令，#define配合使用</p>
<p>需要引用命名空间using System.Diagnostics;<br>主要可以用在一些调试代码上<br>有时想执行有时不想执行的代码</p>
<pre><code class="c#">#define Fun
[Conditional(&quot;Fun&quot;)]                       //必须通过#define命名一个Fun（类似#if），才会执行这个函数
static void Fun()
&#123;
    Console.WriteLine(&quot;执行Fun&quot;);
&#125;
</code></pre>
<h2 id="八、系统自带特性-——-外部Dll包函数特性"><a href="#八、系统自带特性-——-外部Dll包函数特性" class="headerlink" title="八、系统自带特性 —— 外部Dll包函数特性"></a>八、系统自带特性 —— 外部Dll包函数特性</h2><p>DllImport<br>用来标记非.Net(C#)的函数，表明该函数在一个外部DLL中定义<br>一般用来调用 C或者C++的Dll包写好的方法<br>需要引用命名空间 using System.Runtime.InteropServices</p>
<pre><code class="c#">[DllImport(&quot;Test.Dll&quot;)]
public static extern int Add(int a, int b);                             //使用其他语言的Dll包的方法
</code></pre>
<h1 id="知识点十一-迭代器"><a href="#知识点十一-迭代器" class="headerlink" title="知识点十一 迭代器"></a>知识点十一 迭代器</h1><h2 id="一、迭代器是什么"><a href="#一、迭代器是什么" class="headerlink" title="一、迭代器是什么"></a>一、迭代器是什么</h2><p>迭代器（iterator），有时又称光标（cursor）<br>是程序设计的软件设计模式<br>迭代器模式提供一个方法顺序访问一个聚合对象中的各个元素<br>而又不暴露其内部的标识</p>
<p>在表现效果上看<br>是可以在容器对象（例如链表或数组）上遍历访问的接口<br>设计人员无需关心容器对象的内存分配的实现细节<br>可以用foreach遍历的类，都是实现了迭代器的</p>
<p>foreach的本质</p>
<ul>
<li>先获取in后面这个对象的 IEnumerator，通过调用GetEnumerator方法来获取</li>
<li>执行得到的这个IEnumerator对象中的 MoveNext方法</li>
<li>只要MoveNext方法返回值是true 就会得到Current，赋值给item</li>
</ul>
<h2 id="二、标准的迭代器实现方法"><a href="#二、标准的迭代器实现方法" class="headerlink" title="二、标准的迭代器实现方法"></a>二、标准的迭代器实现方法</h2><p>关键接口：IEnumerator, IEnumerable<br>命名空间：using System.Collections;<br>可以通过同时继承IEnumerator和IEnumerable直接实现其中的方法<br>例如</p>
<pre><code class="c#">class CustomList : IEnumerable, IEnumerator
&#123;
    private int[ ] list;
    private int position = -1;       //声明一个光标，注意设置初始值为-1，才能从第一个数开始迭代
        
    public CustomList()
    &#123;
        list = new int[ ] &#123; 1, 2, 3, 4, 5, 6, 7, 8 &#125;;
    &#125;

    public IEnumerator GetEnumerator()             //IEnumerable接口方法
    &#123;
        Reset();
        return this;
    &#125;

    //以下三个都是继承了IEnumerator接口实现的方法
    public object Current;          //当前光标标记的值
    &#123;
        get
        &#123;
            return list[position];
        &#125;
    &#125;
    public bool MoveNext()      //移动到下一个的逻辑，返回true则返回Current
    &#123;
        ++position;
        return position &lt; list.Length;          //是否溢出，溢出就不合法
    &#125;

    public void Reset()         //光标复原，在GetEnumerator方法的返回值前调用
    &#123;
        position = -1;                                
    &#125;
&#125;
</code></pre>
<h2 id="三、用yield-return-语法糖实现迭代器"><a href="#三、用yield-return-语法糖实现迭代器" class="headerlink" title="三、用yield return 语法糖实现迭代器"></a>三、用yield return 语法糖实现迭代器</h2><p>yield return是c#提供给我们的语法糖<br>所谓语法糖，也称糖衣语法<br>主要作用是将复杂逻辑简单化，可以增加程序的可读性<br>从而减少程序代码出错的机会</p>
<p>关键接口：IEnumerable<br>命名空间：using System.Collections;<br>让想通过foreach遍历的自定义类实现接口中的方法GetEnumerator节课即可</p>
<pre><code class="c#">class CustomList2 : IEnumerable
&#123;
    pubilc int[] list;

    public CustomList2()
    &#123;
        list = new int[ ] &#123; 1, 2, 3, 4, 5, 6, 7, 8 &#125;;
    &#125;

    public IEnumerator GetEnumerator
    &#123;
        for( int i = 0; i &lt; list.Length; i++)
        &#123;
            //yield关键字 配合迭代器使用，可以理解为暂时返回，保留当前状态
            //C#语法糖
            yield return list [ i ];
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="四、用yield-return-语法糖为泛型类实现迭代器"><a href="#四、用yield-return-语法糖为泛型类实现迭代器" class="headerlink" title="四、用yield return 语法糖为泛型类实现迭代器"></a>四、用yield return 语法糖为泛型类实现迭代器</h2><pre><code class="c#">class CustomList&lt;T&gt; : IEnumerable
&#123;
    private T[ ] array;
    public CustomList( params T[] array )
    &#123;
        this.array = array;
    &#125;
    public IEnumerator GetEnumerator()
    &#123;
        for( int i = 0; i &lt; array.Length; i++ )
        &#123;
            yield return array[ i ];
        &#125;
    &#125;
&#125;
</code></pre>
<h1 id="知识点十二-特殊语法"><a href="#知识点十二-特殊语法" class="headerlink" title="知识点十二 特殊语法"></a>知识点十二 特殊语法</h1><h2 id="一、var隐式类型"><a href="#一、var隐式类型" class="headerlink" title="一、var隐式类型"></a>一、var隐式类型</h2><p>var是一种特殊的变量类型<br>它可以用来表示任意类型的变量<br>注意：<br>a.var不能作为类的成员，只能用于临时变量申明时<br>也就是，一般写在函数语句块中<br>b.var必须初始化<br>初始化之后，就不能装载其他类型</p>
<pre><code class="c#">var i = 5;
var str = &quot;123&quot;;
var array = new int[ ]&#123;1, 2, 3&#125;;
</code></pre>
<h2 id="二、设置对象初始值"><a href="#二、设置对象初始值" class="headerlink" title="二、设置对象初始值"></a>二、设置对象初始值</h2><p>申明对象时<br>可以通过直接写大括号的形式初始化公共成员变量和属性<br>例如</p>
<pre><code class="c#">class Person
&#123;
    public string name;
    public int age;
    public bool sex
    &#123;
        get;
        set;        
    &#125;
&#125;
Person p = new Person()&#123; string = &quot;cong&quot;, age = 15, sex = true &#125;;        //不一定要把成员写全
</code></pre>
<h2 id="三、设置集合初始值"><a href="#三、设置集合初始值" class="headerlink" title="三、设置集合初始值"></a>三、设置集合初始值</h2><p>申明集合对象时<br>也可以通过大括号，直接初始化内部属性</p>
<pre><code class="c#">int[] array = new int[]&#123;1, 2, 3&#125;;
List&lt;int&gt; intList = new List&lt;int&gt;() &#123; 1, 2, 3&#125;;
</code></pre>
<h2 id="四、匿名类型"><a href="#四、匿名类型" class="headerlink" title="四、匿名类型"></a>四、匿名类型</h2><p>var 变量可以申明为自定义的匿名类型</p>
<pre><code class="c#">var v = new &#123; age = 10, name = &quot;66&quot; &#125;; 
//临时定义的类，数据的集合，大括号内可以填写任意变量，只能有成员变量，不能有函数
</code></pre>
<h2 id="五、可空类型"><a href="#五、可空类型" class="headerlink" title="五、可空类型"></a>五、可空类型</h2><ol>
<li>值类型不能赋值为空</li>
<li>申明时，在值类型后面加一个 ? 即可赋值为空</li>
</ol>
<pre><code class="c#">int? c = null;
</code></pre>
<ol start="3">
<li>判断是否为空</li>
</ol>
<pre><code class="c#">if( c.HasValue )
&#123;
    Console.WriteLine(c);
&#125;
</code></pre>
<ol start="4">
<li>安全获取可空类型</li>
</ol>
<pre><code class="c#">int? value = null;
//如果为空，默认返回值类型的默认值
Console.WriteLine( value.GetValueOrDefault());  //打印出0
//也可以指定一个默认值
Console.WriteLine( value.GetValueOrDefault(2));      //在括号中填入一个值为默认值，此为2

object o = null;
o.ToString();        //会报错
o?.ToString();        //相当于语法糖，会自动判断o是否为空，若为空则不会执行ToString()
</code></pre>
<h2 id="六、空合并操作符"><a href="#六、空合并操作符" class="headerlink" title="六、空合并操作符"></a>六、空合并操作符</h2><p>空合并操作符 ??<br>左边值 ?? 右边值<br>如果左边值为null 就返回右边值 否则返回左边值<br>只要是可以为null的类型都可以使用</p>
<pre><code class="c#">int? intv = null;
//三目运算符方法
int i = intv == null ? 100 : intv.Value;
//空合并操作符方法
i = intv ?? 100;
</code></pre>
<h2 id="七、内插字符串"><a href="#七、内插字符串" class="headerlink" title="七、内插字符串"></a>七、内插字符串</h2><p>关键符号：$<br>用$在构造字符串，使字符串可以拼接变量</p>
<pre><code class="c#">string name = &quot;麦大帅&quot;;
Console.WriteLine($&quot;好好学习，&#123;name&#125;&quot; );
</code></pre>
<h2 id="八、单句逻辑的简略写法"><a href="#八、单句逻辑的简略写法" class="headerlink" title="八、单句逻辑的简略写法"></a>八、单句逻辑的简略写法</h2><p>&#x2F;&#x2F;如果If、for、while只有一句代码，则可以省略大括号</p>
<pre><code class="c#">if(true)
    Console.WriteLine(123);

for(int i = 0; i &lt; 10; i++)
    Console.WriteLine(i);

while(true)
    Console.WriteLine(123);

//若只有一句代码，属性简略写法
public string Name
&#123;
    get =&gt; &quot;麦&quot;;
    set =&gt; value;
&#125;

//方法简略写法（一句代码）
pubilc int Add(int a, int b) =&gt; a + b;
</code></pre>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 jaytp@qq.com </span>
    </div>
</article>







    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2024 Paul
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 562px;
    }
    .nav.fullscreen {
        margin-left: -562px;
    }
    .nav-left {
        width: 140px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 512px;
        }
        .nav.fullscreen {
            margin-left: -512px;
        }
        .nav-left {
            width: 120px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 512px;
            margin-left: -512px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
