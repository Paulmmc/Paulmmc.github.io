<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Unity入门 | Paul的博客</title>
  <meta name="keywords" content=" Unity ">
  <meta name="description" content="Unity入门 | Paul的博客">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="知识点一 3D数学————基础一、数学计算公共类Mathf1.Mathf和MathMath是c#中封装好的用于数学计算的工具类 —— 位于System命名空间中Mathf是Unity中封装好的用于数学计算的工具结构体 —— 位于UnityEngine命名空间中他们都是用来提供数学相关计算的 2.Math和Mathf的区别Math 和 Mathf中的相关方法几乎一样Math 是c#自带的工具类，主要">
<meta property="og:type" content="article">
<meta property="og:title" content="Unity基础">
<meta property="og:url" content="https://paulmmc.github.io/2024/10/04/Unity%E7%AC%94%E8%AE%B0/Unity%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Paul的博客">
<meta property="og:description" content="知识点一 3D数学————基础一、数学计算公共类Mathf1.Mathf和MathMath是c#中封装好的用于数学计算的工具类 —— 位于System命名空间中Mathf是Unity中封装好的用于数学计算的工具结构体 —— 位于UnityEngine命名空间中他们都是用来提供数学相关计算的 2.Math和Mathf的区别Math 和 Mathf中的相关方法几乎一样Math 是c#自带的工具类，主要">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-10-04T14:30:55.000Z">
<meta property="article:modified_time" content="2024-10-05T07:42:30.465Z">
<meta property="article:author" content="Paul">
<meta property="article:tag" content="Unity">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 7.3.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>Paul</span>
</div>

<div class="icon">
    
        
    
        
            <a title="github"
               href="https://github.com/Paulmmc"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
            <a title="email"
               href="mailto:3095627551@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=3095627551&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(17)</small>
            
        </div>
    </li>
    
        
            
                
    <li>
        <div data-rel="Unity笔记">
            <i class="fold iconfont icon-right"></i>
            Unity笔记
            <small>(9)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="Unity笔记&lt;---&gt;Unity基础">
            
            Unity基础
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Unity笔记&lt;---&gt;Unity进阶">
            
            Unity进阶
            <small>(7)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Unity笔记&lt;---&gt;Unity入门">
            
            Unity入门
            <small>(1)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="理论基础">
            <i class="fold iconfont icon-right"></i>
            理论基础
            <small>(6)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="理论基础&lt;---&gt;编程语言">
            <i class="fold iconfont icon-right"></i>
            编程语言
            <small>(6)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="理论基础&lt;---&gt;编程语言&lt;---&gt;CSharp">
            
            CSharp
            <small>(4)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="CoscosCretor笔记">
            
            CoscosCretor笔记
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="17">
<input type="hidden" id="yelog_site_word_count" value="78.4k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>CSharp</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Unity</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="全部文章 Unity笔记 Unity基础 "
           href="/2024/10/04/Unity%E7%AC%94%E8%AE%B0/Unity%E5%9F%BA%E7%A1%80/"
           data-tag="Unity"
           data-author="" >
            <span class="post-title" title="Unity基础">Unity基础</span>
            <span class="post-date" title="2024-10-04 22:30:55">2024/10/04</span>
        </a>
        
        
        <a  class="全部文章 Unity笔记 Unity入门 "
           href="/2024/09/27/Unity%E7%AC%94%E8%AE%B0/Unity%E5%85%A5%E9%97%A8/"
           data-tag="Unity"
           data-author="" >
            <span class="post-title" title="Unity入门">Unity入门</span>
            <span class="post-date" title="2024-09-27 23:19:29">2024/09/27</span>
        </a>
        
        
        <a  class="全部文章 理论基础 编程语言 CSharp "
           href="/2024/09/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/CSharp/CSharp%E8%BF%9B%E9%98%B6/"
           data-tag="CSharp"
           data-author="" >
            <span class="post-title" title="CSharp进阶">CSharp进阶</span>
            <span class="post-date" title="2024-09-24 23:02:43">2024/09/24</span>
        </a>
        
        
        <a  class="全部文章 理论基础 编程语言 CSharp "
           href="/2024/09/23/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/CSharp/CSharp%E6%A0%B8%E5%BF%83/"
           data-tag="CSharp"
           data-author="" >
            <span class="post-title" title="CSharp核心">CSharp核心</span>
            <span class="post-date" title="2024-09-23 23:16:21">2024/09/23</span>
        </a>
        
        
        <a  class="全部文章 理论基础 编程语言 CSharp "
           href="/2024/09/23/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/CSharp/CSharp%E5%9F%BA%E7%A1%80/"
           data-tag="CSharp"
           data-author="" >
            <span class="post-title" title="CSharp基础">CSharp基础</span>
            <span class="post-date" title="2024-09-23 22:07:32">2024/09/23</span>
        </a>
        
        
        <a  class="全部文章 理论基础 编程语言 CSharp "
           href="/2024/09/23/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/CSharp/CSharp%E5%85%A5%E9%97%A8/"
           data-tag="CSharp"
           data-author="" >
            <span class="post-title" title="CSharp入门">CSharp入门</span>
            <span class="post-date" title="2024-09-23 20:18:42">2024/09/23</span>
        </a>
        
        
        <a  class="全部文章 Unity笔记 Unity进阶 "
           href="/2024/09/23/Unity%E7%AC%94%E8%AE%B0/Unity%E8%BF%9B%E9%98%B6/InputSystem/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="InputSystem">InputSystem</span>
            <span class="post-date" title="2024-09-23 18:11:34">2024/09/23</span>
        </a>
        
        
        <a  class="全部文章 CoscosCretor笔记 "
           href="/2024/09/23/CocosCreator%E7%AC%94%E8%AE%B0/TS/TypeScript%E8%AF%AD%E8%A8%80/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="TypeScript语言">TypeScript语言</span>
            <span class="post-date" title="2024-09-23 18:00:16">2024/09/23</span>
        </a>
        
        
        <a  class="全部文章 Unity笔记 Unity进阶 "
           href="/2024/09/23/Unity%E7%AC%94%E8%AE%B0/Unity%E8%BF%9B%E9%98%B6/Excel%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Excel数据读取">Excel数据读取</span>
            <span class="post-date" title="2024-09-23 18:00:16">2024/09/23</span>
        </a>
        
        
        <a  class="全部文章 Unity笔记 Unity进阶 "
           href="/2024/09/23/Unity%E7%AC%94%E8%AE%B0/Unity%E8%BF%9B%E9%98%B6/GameFramework/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="GameFramework">GameFramework</span>
            <span class="post-date" title="2024-09-23 18:00:16">2024/09/23</span>
        </a>
        
        
        <a  class="全部文章 Unity笔记 Unity进阶 "
           href="/2024/09/23/Unity%E7%AC%94%E8%AE%B0/Unity%E8%BF%9B%E9%98%B6/Unity%E4%B8%AD%E7%9A%84MVC%E6%80%9D%E6%83%B3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Unity中的MVC思想">Unity中的MVC思想</span>
            <span class="post-date" title="2024-09-23 18:00:16">2024/09/23</span>
        </a>
        
        
        <a  class="全部文章 Unity笔记 Unity进阶 "
           href="/2024/09/23/Unity%E7%AC%94%E8%AE%B0/Unity%E8%BF%9B%E9%98%B6/Unity%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%8B2%E8%BF%9B%E5%88%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Unity数据持久化之2进制">Unity数据持久化之2进制</span>
            <span class="post-date" title="2024-09-23 18:00:16">2024/09/23</span>
        </a>
        
        
        <a  class="全部文章 Unity笔记 Unity进阶 "
           href="/2024/09/23/Unity%E7%AC%94%E8%AE%B0/Unity%E8%BF%9B%E9%98%B6/Unity%E7%BD%91%E7%BB%9C%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Unity网络开发基础">Unity网络开发基础</span>
            <span class="post-date" title="2024-09-23 18:00:16">2024/09/23</span>
        </a>
        
        
        <a  class="全部文章 Unity笔记 Unity进阶 "
           href="/2024/09/23/Unity%E7%AC%94%E8%AE%B0/Unity%E8%BF%9B%E9%98%B6/Unity%E7%BC%96%E8%BE%91%E5%99%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Unity编辑器">Unity编辑器</span>
            <span class="post-date" title="2024-09-23 18:00:16">2024/09/23</span>
        </a>
        
        
        <a  class="全部文章 理论基础 编程语言 "
           href="/2024/09/23/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/C++/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="C++">C++</span>
            <span class="post-date" title="2024-09-23 18:00:16">2024/09/23</span>
        </a>
        
        
        <a  class="全部文章 理论基础 编程语言 "
           href="/2024/09/23/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/TypeScript/TypeScript%E8%AF%AD%E8%A8%80/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="TypeScript">TypeScript</span>
            <span class="post-date" title="2024-09-23 18:00:16">2024/09/23</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2024/09/21/hello-world/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Hello World">Hello World</span>
            <span class="post-date" title="2024-09-21 00:02:38">2024/09/21</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-Unity笔记/Unity入门" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">Unity入门</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="Unity笔记">Unity笔记</a> > 
            
            <a  data-rel="Unity笔记&lt;---&gt;Unity入门">Unity入门</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color1">Unity</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2024-10-05 15:19:19'>2024-09-27 23:19</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:11.5k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80-Unity%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80"><span class="toc-text">知识点一 Unity脚本基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0"><span class="toc-text">一、生命周期函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BA%86%E8%A7%A3%E5%B8%A7%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">1.了解帧的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">2.生命周期函数的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0"><span class="toc-text">3.生命周期函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0-%E6%94%AF%E6%8C%81%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81"><span class="toc-text">4.生命周期函数  支持继承多态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Inpsector%E7%AA%97%E5%8F%A3%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-text">二、Inpsector窗口的变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%A7%81%E6%9C%89%E5%92%8C%E4%BF%9D%E6%8A%A4%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E7%BC%96%E8%BE%91"><span class="toc-text">1.私有和保护无法显示编辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E8%AE%A9%E7%A7%81%E6%9C%89%E7%9A%84%E5%92%8C%E4%BF%9D%E6%8A%A4%E7%9A%84%E4%B9%9F%E5%8F%AF%E4%BB%A5%E8%A2%AB%E6%98%BE%E7%A4%BA"><span class="toc-text">2.如何让私有的和保护的也可以被显示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%85%AC%E5%85%B1%E7%9A%84%E5%8F%AF%E4%BB%A5%E6%98%BE%E7%A4%BA%E7%BC%96%E8%BE%91"><span class="toc-text">3.公共的可以显示编辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%85%AC%E5%85%B1%E7%9A%84%E4%B9%9F%E5%8F%AF%E4%BB%A5%E4%B8%8D%E6%98%BE%E7%A4%BA%E7%BC%96%E8%BE%91"><span class="toc-text">4.公共的也可以不显示编辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%A4%A7%E9%83%A8%E5%88%86%E7%B1%BB%E5%9E%8B%E9%83%BD%E8%83%BD%E6%98%BE%E7%A4%BA%E7%BC%96%E8%BE%91"><span class="toc-text">5.大部分类型都能显示编辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%AE%A9%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E8%A2%AB%E6%98%BE%E7%A4%BA%E7%BC%96%E8%BE%91"><span class="toc-text">6.让自定义类型可以被显示编辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%B8%80%E4%BA%9B%E8%BE%85%E5%8A%A9%E7%89%B9%E6%80%A7"><span class="toc-text">7.一些辅助特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%B3%A8%E6%84%8F"><span class="toc-text">8.注意</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81MonoBehavior%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E5%86%85%E5%AE%B9"><span class="toc-text">三、MonoBehavior中的重要内容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%87%8D%E8%A6%81%E6%88%90%E5%91%98"><span class="toc-text">1.重要成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%87%8D%E8%A6%81%E6%96%B9%E6%B3%95"><span class="toc-text">2.重要方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C-Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI"><span class="toc-text">知识点二 Unity重要组件和API</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%9C%80%E5%B0%8F%E5%8D%95%E4%BD%8DGameObject"><span class="toc-text">一、最小单位GameObject</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-GameObject%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-text">1.GameObject中的成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-GameObject%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">2.GameObject中的静态方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-GameObject%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-text">3.GameObject中的成员方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%97%B6%E9%97%B4%E7%9B%B8%E5%85%B3Time"><span class="toc-text">二、时间相关Time</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%97%B6%E9%97%B4%E7%BC%A9%E6%94%BE%E6%AF%94%E4%BE%8B"><span class="toc-text">1.时间缩放比例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B8%A7%E9%97%B4%E9%9A%94%E6%97%B6%E9%97%B4"><span class="toc-text">2.帧间隔时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%B8%B8%E6%88%8F%E5%BC%80%E5%A7%8B%E5%88%B0%E7%8E%B0%E5%9C%A8%E7%9A%84%E6%97%B6%E9%97%B4"><span class="toc-text">3.游戏开始到现在的时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%89%A9%E7%90%86%E5%B8%A7%E9%97%B4%E9%9A%94%E6%97%B6%E9%97%B4-FixedUpdate"><span class="toc-text">4.物理帧间隔时间 FixedUpdate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%B8%A7%E6%95%B0"><span class="toc-text">5.帧数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E8%BE%93%E5%85%A5Input"><span class="toc-text">三、输入Input</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%BC%A0%E6%A0%87%E5%9C%A8%E5%B1%8F%E5%B9%95%E4%BD%8D%E7%BD%AE"><span class="toc-text">1.鼠标在屏幕位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%A3%80%E6%B5%8B%E9%BC%A0%E6%A0%87%E7%9A%84%E8%BE%93%E5%85%A5"><span class="toc-text">2.检测鼠标的输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%A3%80%E6%B5%8B%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5"><span class="toc-text">3.检测键盘输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%A3%80%E6%B5%8B%E9%BB%98%E8%AE%A4%E8%BD%B4%E8%BE%93%E5%85%A5"><span class="toc-text">4.检测默认轴输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%85%B6%E4%BB%96"><span class="toc-text">5.其他</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%B1%8F%E5%B9%95Screen"><span class="toc-text">四、屏幕Screen</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7"><span class="toc-text">1.静态属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">2.静态方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%91%84%E5%83%8F%E6%9C%BACamera"><span class="toc-text">五、摄像机Camera</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8F%AF%E7%BC%96%E8%BE%91%E5%8F%82%E6%95%B0"><span class="toc-text">1.可编辑参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Camera%E4%BB%A3%E7%A0%81"><span class="toc-text">2. Camera代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89-Transform"><span class="toc-text">知识点三 Transform</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BD%8D%E7%BD%AE%E5%92%8C%E4%BD%8D%E7%A7%BB"><span class="toc-text">一、位置和位移</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E7%82%B9Vector3"><span class="toc-text">1.必备知识点Vector3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BD%8D%E7%BD%AE"><span class="toc-text">2.位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BD%8D%E7%A7%BB"><span class="toc-text">3.位移</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%A7%92%E5%BA%A6%E5%92%8C%E6%97%8B%E8%BD%AC"><span class="toc-text">二、角度和旋转</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%A7%92%E5%BA%A6%E7%9B%B8%E5%85%B3"><span class="toc-text">1.角度相关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%97%8B%E8%BD%AC%E7%9B%B8%E5%85%B3"><span class="toc-text">2.旋转相关</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%BC%A9%E6%94%BE%E5%92%8C%E7%9C%8B%E5%90%91"><span class="toc-text">三、缩放和看向</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BC%A9%E6%94%BE"><span class="toc-text">1.缩放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%9C%8B%E5%90%91"><span class="toc-text">2.看向</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB"><span class="toc-text">四、父子关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%8E%B7%E5%8F%96%E5%92%8C%E8%AE%BE%E7%BD%AE%E7%88%B6%E5%AF%B9%E8%B1%A1"><span class="toc-text">1.获取和设置父对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%88%8D%E5%BC%83%E5%AD%90%E5%AF%B9%E8%B1%A1"><span class="toc-text">2.舍弃子对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%8E%B7%E5%8F%96%E5%AD%90%E5%AF%B9%E8%B1%A1"><span class="toc-text">3.获取子对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%84%BF%E5%AD%90%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">4.儿子的操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2"><span class="toc-text">五、坐标转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%96%E7%95%8C%E5%9D%90%E6%A0%87%E8%BD%AC%E6%9C%AC%E5%9C%B0%E5%9D%90%E6%A0%87"><span class="toc-text">1.世界坐标转本地坐标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9C%AC%E5%9C%B0%E5%9D%90%E6%A0%87%E8%BD%AC%E4%B8%96%E7%95%8C%E5%9D%90%E6%A0%87"><span class="toc-text">2.本地坐标转世界坐标</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B-%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F"><span class="toc-text">知识点四 核心系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%85%89%E6%BA%90%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80"><span class="toc-text">一、光源系统基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%85%89%E6%BA%90%E7%BB%84%E4%BB%B6"><span class="toc-text">1.光源组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%85%89%E6%BA%90%E9%9D%A2%E6%9D%BF"><span class="toc-text">2.光源面板</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F%E4%B9%8B%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B"><span class="toc-text">二、物理系统之碰撞检测</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%9A%E4%BD%93RigidBody"><span class="toc-text">1.刚体RigidBody</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%89%A9%E7%90%86%E6%9D%90%E8%B4%A8Material"><span class="toc-text">2.物理材质Material</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E5%87%BD%E6%95%B0"><span class="toc-text">3.碰撞检测函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%88%9A%E4%BD%93%E5%8A%A0%E5%8A%9B"><span class="toc-text">4.刚体加力</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E9%9F%B3%E6%95%88%E7%B3%BB%E7%BB%9F"><span class="toc-text">三、音效系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%9F%B3%E9%A2%91%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5"><span class="toc-text">1.音频文件导入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%9F%B3%E9%A2%91%E6%BA%90%E5%92%8C%E9%9F%B3%E9%A2%91%E7%9B%91%E5%90%AC%E8%84%9A%E6%9C%AC"><span class="toc-text">2.音频源和音频监听脚本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BB%A3%E7%A0%81%E6%8E%A7%E5%88%B6%E9%9F%B3%E9%A2%91%E6%BA%90"><span class="toc-text">3.代码控制音频源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%BA%A6%E5%85%8B%E9%A3%8E%E8%BE%93%E5%85%A5%E7%9B%B8%E5%85%B3"><span class="toc-text">4.麦克风输入相关</span></a></li></ol></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="知识点一-Unity脚本基础"><a href="#知识点一-Unity脚本基础" class="headerlink" title="知识点一 Unity脚本基础"></a>知识点一 Unity脚本基础</h1><h2 id="一、生命周期函数"><a href="#一、生命周期函数" class="headerlink" title="一、生命周期函数"></a>一、生命周期函数</h2><h3 id="1-了解帧的概念"><a href="#1-了解帧的概念" class="headerlink" title="1.了解帧的概念"></a>1.了解帧的概念</h3><p>游戏本质就是一个死循环，每一次循环处理游戏逻辑，就会更新一次画面，之所以能看到画面在动，是因为切换画面的速度到达一定时，人眼就认为画面是流畅的。<br>一帧就是执行一次循环。</p>
<p>FPS（Frames Per Second）：即每秒帧数。<br>一般我们说的60帧30帧，就是一秒更新60次、30次画面。<br>1s &#x3D; 1000ms<br>60帧：1帧为16.66ms<br>30帧：1帧为33.33ms<br>人眼舒适放松时，可视帧为每秒24帧</p>
<p>游戏卡顿的原因：跑1帧游戏逻辑中的计算量过大，或CPU不给力，不能在1帧内处理完所有游戏逻辑。</p>
<p>Unity底层已经帮助我们做好了死循环，我们需要学习Unity的生命周期函数，利用它做好的规则来执行我们的游戏逻辑即可</p>
<h3 id="2-生命周期函数的概念"><a href="#2-生命周期函数的概念" class="headerlink" title="2.生命周期函数的概念"></a>2.生命周期函数的概念</h3><p>所有继承MonoBehavior的脚本，最终都会被挂载到GameObject游戏对象上<br>生命周期函数，就是该脚本对象依附的GameObject对象从出生到死亡整个生命周期中<br>会通过反射自动调用的一些特殊函数</p>
<p>Unity帮助我们记录了一个GameObject对象依附了哪些脚本<br>会自动的得到这些对象，通过反射去执行一些固定名字的函数</p>
<h3 id="3-生命周期函数"><a href="#3-生命周期函数" class="headerlink" title="3.生命周期函数"></a>3.生命周期函数</h3><p>注意：生命周期函数的访问修饰符一般为private和protect，因为不需要在外部自己调用生命周期函数，都是Unity自己帮助我们调用。</p>
<ol>
<li><p>Awake：<br>（自己这个脚本类对象）出生时调用，类似构造函数，一个对象只会调用一次，比如在游戏运行状态下，将该脚本挂载到一个对象上，就会执行。<br>类似构造函数，我们可以在这个脚本类对象创建时，进行初始化操作</p>
</li>
<li><p>OnEnable：<br>依附的GameObject对象每次激活时调用
     </p>
</li>
<li><p>Start：<br>从自己被创建出来后，第一次帧更新之前调用一个对象只会调用一次<br>还是用于初始化信息，但相对Awake要晚一点</p>
</li>
<li><p>FixedUpdate：<br>物理帧更新，固定间隔时间执行，间隔时间可以设置<br>主要用于物理更新，比如碰撞<br>用于每帧更新，但与游戏帧不同，是额外控制的帧<br>设置间隔时间位置，Edit ——&gt; ProjectSettings ——&gt; Time ——&gt; Fixed Timestep </p>
</li>
<li><p>Update：<br>逻辑帧更新，每帧执行<br>主要用于处理游戏核心逻辑更新的函数        </p>
</li>
<li><p>LateUpdate：<br>每帧执行，于Update之后执行<br>一般这个更新是用于处理摄像机位置更新相关内容<br>实际上，在Update和LateUpdate之间，Unity还做了一些动画相关的更新处理。<br>如果在Update函数内进行摄像机的处理，可能会造成一些错误，所以在LateUpdate函数里进行摄像机处理        </p>
</li>
<li><p>OnDisable：<br>依附的GameObject对象每次失活时调用
     </p>
</li>
<li><p>OnDestroy：<br>对象销毁时调用，依附的GameObject对象被删除时</p>
</li>
</ol>
<p>只调用一次的函数：Awake、Start、OnDestroy<br>可调用多次的函数：</p>
<ul>
<li>激活失活时调用的函数：OnEnable、OnDisable</li>
<li>每帧调用的函数：Update、LateUpdate、FixedUpdate（与前两个不同帧）</li>
</ul>
<p>在Unity中打印信息的两种方式：<br>a.不继承MonoBehavior类的时候</p>
<pre><code class="c#">Debug.Log(&quot;123&quot;);       //打印信息
Debug.LogError(&quot;出错了！！&quot;);            //打印报错
Debug.LogWarning(&quot;警告！！！&quot;);        //打印警告
</code></pre>
<p>b.继承MonoBehavior类的时候，有一个线程的方法可以使用</p>
<pre><code class="c#">print(&quot;123&quot;);                                        //打印信息
</code></pre>
<h3 id="4-生命周期函数-支持继承多态"><a href="#4-生命周期函数-支持继承多态" class="headerlink" title="4.生命周期函数  支持继承多态"></a>4.生命周期函数  支持继承多态</h3><p>注意：如果不使用该生命周期函数，则不要写上，若写上，会浪费性能</p>
<h2 id="二、Inpsector窗口的变量"><a href="#二、Inpsector窗口的变量" class="headerlink" title="二、Inpsector窗口的变量"></a>二、Inpsector窗口的变量</h2><h3 id="1-私有和保护无法显示编辑"><a href="#1-私有和保护无法显示编辑" class="headerlink" title="1.私有和保护无法显示编辑"></a>1.私有和保护无法显示编辑</h3><pre><code class="c#">private int a;        //无法显示
protected int b;        //无法显示
</code></pre>
<h3 id="2-如何让私有的和保护的也可以被显示"><a href="#2-如何让私有的和保护的也可以被显示" class="headerlink" title="2.如何让私有的和保护的也可以被显示"></a>2.如何让私有的和保护的也可以被显示</h3><p>加上强制序列化字段特性<br>[SerializeField]<br>所谓序列化就是把一个对象保存到一个文件或数据库字段中去</p>
<pre><code class="c#">[SerializeField]
private int c;                        //可以显示
[SerializeField]
protected int d;                //可以显示
</code></pre>
<h3 id="3-公共的可以显示编辑"><a href="#3-公共的可以显示编辑" class="headerlink" title="3.公共的可以显示编辑"></a>3.公共的可以显示编辑</h3><pre><code class="c#">public int e;        //可以显示编辑
</code></pre>
<h3 id="4-公共的也可以不显示编辑"><a href="#4-公共的也可以不显示编辑" class="headerlink" title="4.公共的也可以不显示编辑"></a>4.公共的也可以不显示编辑</h3><p>在变量前加上特性<br>[HideInInspector]</p>
<pre><code class="c#">[HideInInspector]
public int f;                        //不显示
</code></pre>
<h3 id="5-大部分类型都能显示编辑"><a href="#5-大部分类型都能显示编辑" class="headerlink" title="5.大部分类型都能显示编辑"></a>5.大部分类型都能显示编辑</h3><p>字典、自定义类型不能显示编辑</p>
<h3 id="6-让自定义类型可以被显示编辑"><a href="#6-让自定义类型可以被显示编辑" class="headerlink" title="6.让自定义类型可以被显示编辑"></a>6.让自定义类型可以被显示编辑</h3><p>在结构体名或自定义类的定义前面  加上序列化特性<br>[System.Serializable]<br>字典怎样都不行</p>
<h3 id="7-一些辅助特性"><a href="#7-一些辅助特性" class="headerlink" title="7.一些辅助特性"></a>7.一些辅助特性</h3><p>a.分组说明特性  Header<br>为成员分组<br>[Header(“分组说明”)]<br>添加后，这个特性以下的部分就会在Inspector窗口上进行分为一组</p>
<p>b.悬停注释  Tooltip<br>为变量添加说明<br>[Tooltip(“说明内容”)]</p>
<p>c.间隔特性  Space()<br>让两个字段间出现间隔<br>[Space()]</p>
<p>d.修饰数值的滑条范围 Range<br>[Range(最小值, 最大值)]</p>
<p>e.多行显示字符串  默认不写参数显示3行<br>写参数就是对应行<br>[Multiline(4)]</p>
<p>f.滚动条显示字符串<br>默认不写参数就是超过3行显示的滚动条<br>[TextArea(3, 4)]<br>最少显示3行，最多显示4行，超过4行就是滚动条</p>
<p>g.为变量添加快捷方法<br>该特性添加在一个变量上方<br>参数1  显示按钮名<br>参数2  方法名  不能有参数<br>[ContextMenuItem(“显示按钮名”, “方法名”)]<br>注意：按钮，右键才会显示。 而方法必须是无参无返回</p>
<p>h.为方法添加特性能够在Inspector中执行<br>该特性添加在一个函数上方<br>[ContextMenu(“测试函数”)]<br>设置好函数后， Inspector ——&gt; 该脚本 ——&gt; 三个点 ——&gt; 执行s</p>
<h3 id="8-注意"><a href="#8-注意" class="headerlink" title="8.注意"></a>8.注意</h3><p>a.Inspector窗口中的变量关联的就是对象的成员变量，运行时改变他们，就是在改变成员变量<br>b.拖拽到GameObject对象后，再改变脚本中变量的默认值，界面上不会改变<br>c.运行中修改的信息不会保存</p>
<h2 id="三、MonoBehavior中的重要内容"><a href="#三、MonoBehavior中的重要内容" class="headerlink" title="三、MonoBehavior中的重要内容"></a>三、MonoBehavior中的重要内容</h2><h3 id="1-重要成员"><a href="#1-重要成员" class="headerlink" title="1.重要成员"></a>1.重要成员</h3><ol>
<li>获取依附的GameObject</li>
</ol>
<pre><code class="c#">print(gameObject);      //打印出来
print(this.gameObject);
</code></pre>
<ol start="2">
<li>获取依附的GameObject的位置信息</li>
</ol>
<pre><code class="c#">print(this.transform.position);                //打印这个对象的位置信息
print(this.transform.eulerAngles);                //打印这个对象的（欧拉角）角度信息
print(this.transform.lossyScale);                //打印这个对象的缩放信息
也可以        this.gameObject.transform.position
</code></pre>
<ol start="3">
<li>获取脚本是否激活</li>
</ol>
<pre><code class="c#">this.enabled = true;        //设成激活
this.enabled = false;        //设成失活
</code></pre>
<ol start="4">
<li>获取别的脚本的GameObject<br>先声明<br>public 类名 名字<br>然后在外部拖入即可<br>this  就改为  名字</li>
</ol>
<pre><code class="c#">例如
public Test t;
print(t.gameObject.name);
</code></pre>
<h3 id="2-重要方法"><a href="#2-重要方法" class="headerlink" title="2.重要方法"></a>2.重要方法</h3><p>得到依附对象上挂载的其他脚本<br>假设已经创建了一个名为  “Test”   的脚本        </p>
<ol>
<li>得到GameObject自己挂载的单个脚本<br>只要能得到场景中别的对象或者对象依附的脚本，那就能获取它的所有信息</li>
</ol>
<pre><code class="c#">//根据脚本获取        
//如果没有找到对应的脚步，会默认返回null
this.GetComponent(&quot;脚本名&quot;);
//比如
Test t = this.GetComponent(&quot;Test&quot;) as Test;       
//返回的是一个Component类，是所有脚本的父类，所以要as
//根据type获取
Test t = this.GetComponent(typeof(Test)) as Test;
//根据泛型获取
Test t = this.GetComponent&lt;Test&gt;();
//注意：如果一个GameObject上挂载了多个同种脚本，就无法确定这里用的是哪一个脚本
</code></pre>
<ol start="2">
<li>得到自己挂载的多个脚本</li>
</ol>
<pre><code class="c#">//得到自己挂载的多个相同的脚本
Test[ ] array = this.GetComponents&lt;Test&gt;();        //返回一个Test类的数组
//另一种方法
List&lt;Test&gt; testList = new List&lt;Test&gt;();                //创建一个List
this.GetComponents&lt;Test&gt;(testList);                //用该List存储这个结果
</code></pre>
<ol start="3">
<li>得到该GameObject子对象挂载的脚本（它默认也会找GameObject自己身上是否挂载了该脚本）</li>
</ol>
<pre><code class="c#">//默认为false，失活的子对象不查找        
TestSon tS = this.GetComponentInChildren&lt;TestSon&gt;();       
//ture，失活的子对象也查找
TestSon tS = this.GetComponentInChildren&lt;TestSon&gt;(true);       
//得多个脚本，用法与上面的相同
TestSon[] array = this.GetComponentsInChildren&lt;TestSon&gt;(true);
List&lt;TestSon&gt; lTS = new List&lt;TestSon&gt;();
this.GetComponentsInChildren&lt;TestSon&gt;(true, lTS);
</code></pre>
<ol start="4">
<li>得到父对象挂载的脚本（它默认也会找GameObject自己身上是否挂载了该脚本）</li>
</ol>
<pre><code class="c#">TestFather t = this.GetComponentInParent&lt;TestFather&gt;(); 
</code></pre>
<ol start="5">
<li>尝试获取脚本</li>
</ol>
<pre><code class="c#">Test t3;
bool isHave = this.TryGetComponent&lt;Test&gt;(out t3);
</code></pre>
<h1 id="知识点二-Unity重要组件和API"><a href="#知识点二-Unity重要组件和API" class="headerlink" title="知识点二 Unity重要组件和API"></a>知识点二 Unity重要组件和API</h1><h2 id="一、最小单位GameObject"><a href="#一、最小单位GameObject" class="headerlink" title="一、最小单位GameObject"></a>一、最小单位GameObject</h2><h3 id="1-GameObject中的成员变量"><a href="#1-GameObject中的成员变量" class="headerlink" title="1.GameObject中的成员变量"></a>1.GameObject中的成员变量</h3><pre><code class="c#">//1.1名字
print(this.gameObject.name);        //打印名字
this.gameObject.name = &quot;新名字&quot;;        //改名字，场景中的名字也会改变

//1.2是否激活
print( this.gameObject.activeSelf );        //打印出是否激活，true则激活

//1.3是否是静态
print( this.gameObject.isStatic );

//1.4层级
print( this.gameObject.layer );         //返回一个int值

//1.5标签
print( this.gameObject.tag );           //返回一个字符串

//1.6 transform
print( this.gameObject.transform.position );
print( this.transform.position );   //与上一行相等，都是gameObject的位置信息
</code></pre>
<h3 id="2-GameObject中的静态方法"><a href="#2-GameObject中的静态方法" class="headerlink" title="2.GameObject中的静态方法"></a>2.GameObject中的静态方法</h3><ol>
<li>创建自带几何体</li>
</ol>
<pre><code class="c#">GameObjcet.CreatePrimitive(PrimitiveType.Cube);   //创建一个立方体，也有其他形状，有返回值
GameObject obj = GameObjcet.CreatePrimitive(PrimitiveType.Cube);   
obj.name = &quot;自己创建的立方体&quot;;     //用代码创建一个立方体，并取名
</code></pre>
<ol start="2">
<li>查找对象相关<br>无法找到失活的对象，只能找到激活的对象<br>如果场景中存在多个满足相同条件的对象，只能随机找到一个，不能指定某个<br>得到某个单个对象目前有两种方式：1.public从外部面板拖入关联; 2.通过Api找</li>
</ol>
<pre><code class="c#">//2.2.1查找单个对象：
//2.2.1.1通过名字查找（效率低下，因为他会遍历场景中所有对象，如果对象多就消耗性能）
//找到了就返回一个GameObject对象，若没找到则返回一个null
GameObject obj2 = GameObject.Find(&quot;要查找的对象的名字&quot;);     
//2.2.1.2通过tag（标签）来查找
//找到了就返回一个GameObject对象，若没找到则返回一个null
GameObject obj3 = GameObjcet.FindWithTag(&quot;要查找的标签&quot;); 
//上下两个效果一样，只是名字不同
GameObject obj4 = GameObject.FindGameObjectWithTag(&quot;要查找的标签&quot;);

//2.2.2查找多个对象
//找多个对象的Api，只能通过tag找多个
//返回一个GameObject的数组，只能找到激活的对象，无法找到失活的对象
GameObject[] objs = GameObject.FindGameObjectsWithTag(&quot;输入要查找的标签&quot;);

//2.2.3其他查找对象的方法
//是GameObject的父对象Object的方法
//注意：这个Object与万物之父不同，这个是Unity里的Object，命名空间是UnityEngine，也是集成了万物之父的自定义类。而万物之父的命名空间是System
//可以找到场景挂载的某个脚本对象，先遍历一个对象，再遍历这个对象挂载的脚本，效率很低
某个脚本的类名 自己取名 = GameObject.FindObjectOfType&lt;某个脚本的类名&gt;();
</code></pre>
<ol start="3">
<li>实例化对象（克隆对象）的方法（常用）</li>
</ol>
<pre><code class="c#">//实例化对象（克隆对象）的作用：根据一个GameObject对象，创建出一个与它相同的对象
//先public一个GameObject，从外部拖上去关联（场景中的对象或预设体）
public GameObject obj; 
GameObject.Instantiate(obj);     //有返回值，为GameObject
//如果继承了MoneBehavior，则不写GameObject也可以使用
//比如        
Instantiate(obj);
</code></pre>
<ol start="4">
<li>删除对象方法（常用）</li>
</ol>
<p> </p>
<pre><code class="c#">GameObject.Destroy(obj);               //括号内写一个GameObject对象
GameObjectDestroy(obj, 5);                //参数二代表延迟5秒删除
//Destroy可以删除脚本
//Destroy方法原理：为了避免卡顿，Destroy不会马上移除对象，只是给这个对象打一个移除标识，Unity内部会在下一帧时，将这个对象移除，并从内存中移除
GameObject.DestroyImmediate(obj);                //这个方法可以马上移除，而不等下一帧
</code></pre>
<ol start="5">
<li>过场景不移除（常用）</li>
</ol>
<pre><code class="c#">默认在切换场景时，场景中的对象都会被自动删除，如果希望某个对象在换场景后而不被移除则使用这个方法
GameObject.DontDestroyOnLoad(this.gameObject);        //表示自己依附的对象不会被移除
</code></pre>
<h3 id="3-GameObject中的成员方法"><a href="#3-GameObject中的成员方法" class="headerlink" title="3.GameObject中的成员方法"></a>3.GameObject中的成员方法</h3><ol>
<li>创建空物体</li>
</ol>
<pre><code class="c#">//直接new一个，就可以创建空物体，有三种重载
GameObject obj6 = new GameObject();        
GameObject obj7 = new GameObject(&quot;创建的空物体的名字&quot;);
//创建一个空物体，并为其依附脚本，是变长参数，可依附多个
GameObject obj8 = new GameObject(&quot;创建空物体的名字&quot;, typeof(脚本名),...(可加多个脚本));
</code></pre>
<ol start="2">
<li>为对象添加脚本</li>
</ol>
<pre><code class="c#">//动态添加继承MonoBehavior的脚本在某个对象上
obj.AddComponent(typeof(脚本名));
obj.AddComponent&lt;脚本名&gt;();
//比如
Test t = obj.AddComponent(typeof(Test)) as Test;                //返回一个脚本类，用一个对象来装载
Test t = obj.AddComponent&lt;Test&gt;();                                 //返回一个脚本类，用一个对象来装载
</code></pre>
<ol start="3">
<li><p>得到脚本<br>和继承Mono类得到脚本的方法一样</p>
</li>
<li><p>标签比较</p>
</li>
</ol>
<pre><code class="c#">this.gameObject.CompareTag(&quot;输入要比较的标签&quot;);   //返回一个Bool值，表示这个对象的标签与传入的字符串相比较
//上下方的方法一样
this.gameObject.tag == &quot;输入要比较的标签&quot;;
</code></pre>
<ol start="5">
<li>设置激活失活<br>false使这个脚本依附的GameObject失活，true则是激活</li>
</ol>
<pre><code class="c#">obj.SetActive(false);
</code></pre>
<p>次要成员方法，了解即可，不建议使用，效率比较低。<br>通过广播或发送消息的形式，让自己或者别人，执行某些行为方法<br>6. 通知自己执行什么行为<br>命令自己去执行TestFun这个函数，会在自己挂载的所有脚本里去寻找这个名字的函数并执行<br>会去找到自己身上所有脚本，有此名字的函数去执行，后面可以添加传入的参数</p>
<pre><code class="c#">this.gameObject.SendMessage(&quot;TestFun&quot;);
this.gameObject.SendMessage(&quot;TestFun&quot;, 199);
//广播行为，找自己和自己的子对象的函数去执行
this.gameObject.BroadcastMessage(&quot;TestFun&quot;);
//向父对象和自己发送消息，并执行
this.gameObject.SendMessageUpwards(&quot;TestFun&quot;);
</code></pre>
<h2 id="二、时间相关Time"><a href="#二、时间相关Time" class="headerlink" title="二、时间相关Time"></a>二、时间相关Time</h2><h3 id="1-时间缩放比例"><a href="#1-时间缩放比例" class="headerlink" title="1.时间缩放比例"></a>1.时间缩放比例</h3><pre><code class="c#">//1.1时间停止
Time.timeScale = 0;
//1.2恢复正常
Time.timeScale = 1;
//1.3两倍速
Time.timeScale = 2;
</code></pre>
<h3 id="2-帧间隔时间"><a href="#2-帧间隔时间" class="headerlink" title="2.帧间隔时间"></a>2.帧间隔时间</h3><p>帧间隔时间：最近的一帧用了多长时间（单位：秒）<br>主要是用来计算位移的。        路程 &#x3D; 时间*速度</p>
<pre><code class="c#">//2.1受scale影响
print(Time.deltaTime);
//2.2 不受scale影响
print(Time.unscaleDeltaTime);
</code></pre>
<h3 id="3-游戏开始到现在的时间"><a href="#3-游戏开始到现在的时间" class="headerlink" title="3.游戏开始到现在的时间"></a>3.游戏开始到现在的时间</h3><p>主要用来单机游戏的计时</p>
<pre><code class="c#">//3.1受scale影响
print(Time.time);
//3.2不受scale影响
print(Time.unscaleTime);
</code></pre>
<h3 id="4-物理帧间隔时间-FixedUpdate"><a href="#4-物理帧间隔时间-FixedUpdate" class="headerlink" title="4.物理帧间隔时间 FixedUpdate"></a>4.物理帧间隔时间 FixedUpdate</h3><pre><code class="c#">//4.1受scale影响
print(Time.fixedDeltaTime);
//4.2不受scale影响
print(Time.fixedUnscaleDeltaTime);
</code></pre>
<h3 id="5-帧数"><a href="#5-帧数" class="headerlink" title="5.帧数"></a>5.帧数</h3><p>从游戏开始到现在跑了多少帧</p>
<pre><code class="c#">print(Time.frameCount);
</code></pre>
<h2 id="三、输入Input"><a href="#三、输入Input" class="headerlink" title="三、输入Input"></a>三、输入Input</h2><h3 id="1-鼠标在屏幕位置"><a href="#1-鼠标在屏幕位置" class="headerlink" title="1.鼠标在屏幕位置"></a>1.鼠标在屏幕位置</h3><p>屏幕坐标的原点是在屏幕的左下角，往右是x正方形，往上是y正方向<br>返回值是Vector3，但z是0，只有xy有值</p>
<pre><code class="c#">Input.mousePosition
</code></pre>
<h3 id="2-检测鼠标的输入"><a href="#2-检测鼠标的输入" class="headerlink" title="2.检测鼠标的输入"></a>2.检测鼠标的输入</h3><p>作用：可以发射子弹，可以控制摄像机转动</p>
<ol>
<li>鼠标按下一瞬间 进入<br>0左键 1右键 2中键<br>传入一个参数，这个表示若按下左键的一瞬间，返回true</li>
</ol>
<pre><code class="c#">Input.GetMouseButtonDown(0)               
</code></pre>
<ol start="2">
<li>鼠标抬起一瞬间 进入<br>传入一个参数，这个表示若按下左键后抬起的一瞬间，返回true</li>
</ol>
<p> </p>
<pre><code class="c#">Input.GetMouseButtonUp(0)
</code></pre>
<ol start="3">
<li>鼠标长按按下抬起都会进入<br>按住鼠标就会一直打印</li>
</ol>
<pre><code class="c#">Input.GetMouseButton(0)
</code></pre>
<ol start="4">
<li>中键滚动<br>返回值  下(0, -1)    没有滚(0, 0)    上(0, 1)<br>返回一个Vector2的值</li>
</ol>
<pre><code class="c#">Input.mouseScrollDelta
</code></pre>
<h3 id="3-检测键盘输入"><a href="#3-检测键盘输入" class="headerlink" title="3.检测键盘输入"></a>3.检测键盘输入</h3><ol>
<li>键盘按下<br>按下某个键，返回一个true</li>
</ol>
<pre><code class="c#">Input.GetKeyDown(KeyCode.W)
//也可以传入字符串，传入的字符串不能是大写，只能是小写
Input.GetKeyDown(&quot;w&quot;)
</code></pre>
<ol start="2">
<li>键盘抬起</li>
</ol>
<pre><code class="c#">Input.GetKeyUp(KeyCode.W)
</code></pre>
<ol start="3">
<li>键盘长按</li>
</ol>
<pre><code class="c#">Input.GetKey(KeyCode.W);
</code></pre>
<h3 id="4-检测默认轴输入"><a href="#4-检测默认轴输入" class="headerlink" title="4.检测默认轴输入"></a>4.检测默认轴输入</h3><p>更方便的方法控制位移和旋转</p>
<ol>
<li>键盘A D按下时，返回  -1到1之间的值的变换<br>我们可以通过这个值，控制对象左右移动，或者左右旋转</li>
</ol>
<pre><code class="c#">Input.GetAxis(&quot;Horizontal&quot;);    //返回一个float
</code></pre>
<ol start="2">
<li>键盘SW按下时 返回 -1到1之间的值</li>
</ol>
<pre><code class="c#">Input.GetAxis(&quot;Vertical&quot;);   
</code></pre>
<ol start="3">
<li>鼠标横向移动时  -1到1  左右移动</li>
</ol>
<pre><code class="c#">Input.GetAxis(&quot;Mouse X&quot;);   
</code></pre>
<ol start="4">
<li>鼠标竖向移动时  -1到1  上下移动</li>
</ol>
<pre><code class="c#">Input.GetAxis(&quot;Mouse Y&quot;);   
</code></pre>
<ol start="5">
<li>GetAxisRaw和GetAxis方法相同，但只会返回-1、0、1三个值，不会返回中间值</li>
</ol>
<h3 id="5-其他"><a href="#5-其他" class="headerlink" title="5.其他"></a>5.其他</h3><ol>
<li>是否有任意键或鼠标长按</li>
</ol>
<pre><code class="c#">Input.anyKey                                        //返回一个bool
</code></pre>
<ol start="2">
<li>是否有任意键或鼠标按下</li>
</ol>
<pre><code class="c#">Input.anyKeydown                                  //返回一个bool
</code></pre>
<ol start="3">
<li>得到这一帧的键盘输入</li>
</ol>
<pre><code class="c#">Input.inputString                                        //返回一个string
</code></pre>
<ol start="4">
<li>手柄相关</li>
</ol>
<pre><code class="c#">//得到连接的手柄所有按钮的名字
Input.GetJoystickNames();                        //返回一个字符串的数组
//某一个手柄键按下
Input.GetButtonDown(&quot;一个名字&quot;);                //传入一个名字与手柄按钮名对应，返回bool
//某一个手柄键抬起
Input.GetButtonUp(&quot;一个名字&quot;);                //传入一个名字与手柄按钮名对应，返回bool
//某一个手柄键长按
Input.GetButton(&quot;一个名字&quot;);                //传入一个名字与手柄按钮名对应，返回bool
</code></pre>
<ol start="5">
<li>移动设备触摸相关</li>
</ol>
<pre><code class="c#">if( Input.touchCount &gt; 0 )
&#123;
    Touch t1 = Input.touches[0];
    print(t1.position);
    print(t1.deltaPosition);
&#125;
//是否启用多点触碰
Input.multiTouchEnabled = true;
</code></pre>
<ol start="6">
<li>陀螺仪（重力感应）</li>
</ol>
<pre><code class="c#">//是否开启陀螺仪
Input.gyro.enabled = true;
//重力加速度向量
Input.gyro.gravity        一个Vector3的值
//旋转速度
Input.gyro.rotationRate        一个Vector3值
//陀螺仪当前旋转的四元数
//用这个角度信息 控制 场景上一个3d物体收到重力影响
//手机怎么动，它怎么动
Input.gyro.attitute
</code></pre>
<h2 id="四、屏幕Screen"><a href="#四、屏幕Screen" class="headerlink" title="四、屏幕Screen"></a>四、屏幕Screen</h2><h3 id="1-静态属性"><a href="#1-静态属性" class="headerlink" title="1.静态属性"></a>1.静态属性</h3><ol>
<li>常用</li>
</ol>
<pre><code class="c#">//当前屏幕分辨率
print(Screen.CurrentResolution);                //返回值是一个Resolution，得的是

//显示器的分辨率
//游戏窗口当前宽高
Screen.width;                        //当前窗口的宽，不是设备的
Screen.height;                        //当前窗口的高，不是设备的

//屏幕休眠模式
Screen.sleepTimeout = SleepTimeout.NeveSleep;                //设置不休眠
</code></pre>
<ol start="2">
<li>不常用</li>
</ol>
<pre><code class="c#">//运行时是否全屏
Screen.fullScreen = true;

//窗口模式（独占全屏、全屏窗口、最大化窗口、窗口模式）
Screen.fullScreenMode = FullScreenMode.ExclusiveFullScreen;        //独占全屏
FullScreenMode.FullScreenWindow               //全屏窗口
FullScreenMode.MaximizedWindow        //最大化窗口     
FullScreenMode.Windowed              //窗口模式

//移动设备屏幕转向相关
Screen.autorotateToLandscapeLeft = true;    //允许自动旋转为左横向 Home键在左
Screen.autorotateToLandscapeRight = true;   //右横向 Home键在右
Screen.autorotateToPortrait = true;     //纵向 Home键在下
Screen.autorotateToPortraitUpsideDown = true;   //倒着 Home键在上

//指定屏幕显示方向
Screen.orientation = ScreenOrientation.AutoRotation        //所有方向都行
</code></pre>
<h3 id="2-静态方法"><a href="#2-静态方法" class="headerlink" title="2.静态方法"></a>2.静态方法</h3><p>设置分辨率，一般移动设备不使用<br>参数一：宽<br>参数二：高<br>参数三：是否全屏</p>
<pre><code class="c#">Screen.SetResolution(1920,1080,true);
</code></pre>
<h2 id="五、摄像机Camera"><a href="#五、摄像机Camera" class="headerlink" title="五、摄像机Camera"></a>五、摄像机Camera</h2><h3 id="1-可编辑参数"><a href="#1-可编辑参数" class="headerlink" title="1.可编辑参数"></a>1.可编辑参数</h3><ol>
<li>Clear Flags（如何清除背景）<br>skybox 天空盒（渲染天空和大地）<br>Soild Color 颜色填充（一般2d游戏使用）<br>Depth only 只画该层，背景透明<br>Don’t Clear 不移除，覆盖渲染（不擦除上一帧的内容，会形成残影）</li>
<li>Culling Mask（选择性渲染部分层级）<br>可以指定渲染对应层级  Layer<br>若取消渲染指定层级，该层级的物体就不会被摄像机渲染</li>
<li>Projection（透视方式）<br>3.1 Perspective（透视模式，3D游戏，近大远小）<br>以下是选择Perspective出现的参数<br>3.1.1 FOV Axis（视场角 轴）<br>决定了光学仪器的视野范围<br>可选竖直方向和水平方向，选择后，下面Field of view（视口大小）设置的数值就是改变竖直或者水平<br>3.1.2 Field of view（视口大小）<br>类似长焦摄像机和短焦摄像机<br>3.1.3 Physical Camera（物理摄像机）<br>勾选后可以模拟真是世界的摄像机<br>Focal Length（焦距）<br>Sensor Type（传感器类型）<br>Sensor Size（传感器尺寸）<br>Lens Shift（透镜位移）<br>Gate Fit（闸门配合）</li>
</ol>
<p>3.2 Orthographic（正交摄像机，一般用于2D游戏，无近大远小）<br>Size（摄制范围）<br>4. Clipping Planes（裁剪平面距离）<br>设置一个距离，在该距离内的物体才能被看到<br>4.1Near<br>摄像头面前<br>4.2Far<br>离摄像头最远<br>5. Depth（渲染顺序上的深度）<br>深度越大，越后被渲染<br>一般与Clear Flags的Depth Only配合<br>6. Target Texture（渲染纹理）<br>可以把摄像机渲染的内容，渲染到一张图上，主要用于制作小地图<br>在Project窗口，右键Create新建一个Render Texture，可以把这个新建的Render Texture拖到Target Texture上<br>7. Occlusion Culling（是否启用剔除遮挡）<br>若勾选，则被遮挡的物体会直接不渲染，提升性能<br>8. Viewport Rect（视口范围）<br>在屏幕上的显示范围，主要用于双摄像机游戏（双人成行），0~1相当于宽高百分比<br>9. Redering path（渲染路径，了解）<br>10. Allow HDR（是否允许高动态范围渲染）<br>11. Allow MSAA（是否允许抗锯齿）<br>12. Allow Dynamic Resolution（是否允许动态分辨率）<br>13. Target Display（用于哪个显示器）<br>主要用于开发多屏幕的平台游戏</p>
<h3 id="2-Camera代码"><a href="#2-Camera代码" class="headerlink" title="2. Camera代码"></a>2. Camera代码</h3><ol>
<li>重要的静态成员</li>
</ol>
<pre><code class="c#">//1.1获取摄像机
//主摄像机的获取
Camera.main                       //要获取主摄像机，场景中的主摄像机的Tag必须是MainCamera
//获取场景中所有摄像机的数量
Camera.allCameraCount
//获取所有摄像机
Camer[] a = Camera.allCameras;               //返回一个数组     

//1.2渲染相关
//摄像机剔除（被挡住的物体）前处理的委托函数
Camera.onPreCull += (c) =                         //c为Camera类型参数
&#123;
      //逻辑代码  
&#125;;
//摄像机渲染前处理的委托
Camera.onPreRender += (c) =&gt;                 //c为Camera类型参数
&#123;
         //逻辑代码  
&#125;;
//摄像机渲染后处理的委托                        //c为Camera类型参数
Camera.onPostRender += (c) =&gt;
&#123;
        //逻辑代码  
&#125;;
</code></pre>
<ol start="2">
<li>重要成员</li>
</ol>
<pre><code class="c#">//2.1界面上的参数，都可以在Camera获取和设置
print(Camera.main.depth);
//2.2世界坐标转屏幕坐标
//传入一个Vector3，返回值x和y表示屏幕的坐标，z表示离摄像机的z轴的距离
//制作头顶血条相关的功能
Camera.main.WorldToScreenPoint(new Vector3(1, 1, 1));   
//2.3屏幕坐标转世界坐标  
//z轴表示，离摄像机z轴一定距离的面，若z为0表示，这个面是摄像机前的一个点
Camer.main.ScreenToWorldPoint(new Vector(1, 1, 1));
</code></pre>
<h1 id="知识点三-Transform"><a href="#知识点三-Transform" class="headerlink" title="知识点三 Transform"></a>知识点三 Transform</h1><h2 id="一、位置和位移"><a href="#一、位置和位移" class="headerlink" title="一、位置和位移"></a>一、位置和位移</h2><h3 id="1-必备知识点Vector3"><a href="#1-必备知识点Vector3" class="headerlink" title="1.必备知识点Vector3"></a>1.必备知识点Vector3</h3><p>Vector3主要是用来表示三维坐标系中的一个点和一个向量</p>
<ol>
<li>申明</li>
</ol>
<pre><code class="c#">Vector3 v = new Vector3();
v.x = 10;
v.y = 10;
v.z = 10;
Vector3 v2 = new Vector3(10, 10);                //如果只传2个值，则z默认为0
Vector3 v3 = new Vector3(10, 10, 10);                //一步到位
Vector3 v4;
</code></pre>
<ol start="2">
<li>基本计算<br>+、-、*、&#x2F;</li>
</ol>
<pre><code class="c#">Vector3 v1 = new Vector(1, 1, 1);
Vector3 v12 = new Vector(2, 2, 2);
print(v1 + v12);                                /x相加，y相加，z相加
print(v1 - v12);                                /x相减，y相减，z相减
print(v1 * 10);
print(v1 / 10);
</code></pre>
<ol start="3">
<li>常用<br>一些静态量，作为向量使用</li>
</ol>
<pre><code class="c#">print(Vector3.zero);                //0,0,0
print(Vector3.right);                //1,0,0
print(Vector3.left);                  //-1,0,0
print(Vector3.forward);          //0,0,1
print(Vector3.back);                //0,0,-1
print(Vector3.up);                    //0,1,0
print(Vector3.down);                //0,-1,0
//常用方法
//计算两个点之间的距离
Vector.Distance(v1,v12);                //内部传入两个点，即可计算两点间的距离
</code></pre>
<h3 id="2-位置"><a href="#2-位置" class="headerlink" title="2.位置"></a>2.位置</h3><ol>
<li>相对世界坐标系</li>
</ol>
<pre><code class="c#">this.transform                        
this.gameObject.transform     
 //这两种都可以得到transform         
print(this.transform.position);               
//相对世界坐标系，加了父对象也是相对世界坐标系，而不是面板上显示的
</code></pre>
<ol start="2">
<li>相对父对象的位置</li>
</ol>
<pre><code class="c#">print(this.transform.localPosition);     //本地坐标，面板上显示的坐标
</code></pre>
<p>localPosition和Position可能会出现一样的情况：</p>
<ul>
<li>父对象是(0,0,0)坐标时</li>
<li>没有父对象时</li>
</ul>
<ol start="3">
<li>注意：位置的赋值不能只改变x、y、z，必须三个一起改变<br>比如  this.transform.position.x &#x3D; 10;   会报错<br>而  this.transform.position &#x3D; new Vector3(10, 0, 0);  才不会报错<br>或者 this.transform.position &#x3D; Vector3.up * 10;    会变成(0,10,0)<br>只想改一个值x，而y,z保持和原有坐标一致<br>a.直接赋值</li>
</ol>
<pre><code class="c#">this.transform.position = new Vector(10, this.transform.position.y, this.transform.position.z);
</code></pre>
<p>b.先取出来再赋值（虽然不能直接改transform.position的xyz，但vector是可以改的）</p>
<pre><code class="c#">Vector3 vPos = this.transform.position;
vPos.x = 10;
this.transform.position = vPos;
</code></pre>
<ol start="4">
<li>对象当前的各朝向</li>
</ol>
<pre><code class="c#">print(this.transform.forward);
print(this.transform.up);
print(this.transform.right);
...
</code></pre>
<h3 id="3-位移"><a href="#3-位移" class="headerlink" title="3.位移"></a>3.位移</h3><p>坐标系下的位移计算公式<br>路程 &#x3D; 方向 * 速度 * 时间<br>要在Update中计算</p>
<ol>
<li>方式一 自己计算<br>朝自己的正向（Z轴正方向）移动</li>
</ol>
<pre><code class="c#">this.transform.position = this.transform.position + this.transform.forward * 1 * Time.deltaTime;
</code></pre>
<ol start="2">
<li>方式二 API（一般使用API）<br>参数一：表示位移多少  路程 &#x3D; 方向 * 速度 * 时间<br>参数二：表示 相对坐标系        默认该参数是相对自己坐标系<br>相对世界坐标系移动     向世界坐标系的Z轴移动</li>
</ol>
<pre><code class="c#">this.transform.Translate(Vector3.forward * 1 * Time.deltaTime, Space.World); 
//相对世界坐标系的 自己的正方向移动
this.transform.Translate(this.transform.forward * 1 * Time.deltaTime, Space.World); 
//相对于自己坐标系的 自己的正方向移动
this.transform.Translate(Vector.forward * 1 * Time.deltaTime, Space.Self); 
</code></pre>
<h2 id="二、角度和旋转"><a href="#二、角度和旋转" class="headerlink" title="二、角度和旋转"></a>二、角度和旋转</h2><h3 id="1-角度相关"><a href="#1-角度相关" class="headerlink" title="1.角度相关"></a>1.角度相关</h3><p>1.1相对世界坐标的角度<br>print(this.transform.eulerAngles);        &#x2F;&#x2F;这个是界面上Rotation显示的内容<br>1.2相对父对象的角度<br>this.transform.localEulerAngles<br>注意：设置角度不能单独设置xyz，要一起设置<br>this.transform.eulerAngles &#x3D; new Vector(10, 10, 10);</p>
<h3 id="2-旋转相关"><a href="#2-旋转相关" class="headerlink" title="2.旋转相关"></a>2.旋转相关</h3><ol>
<li>自己计算<br>自己计算好，设置位置即可</li>
<li>API计算<br>自转<br>第一个参数：旋转角度和速度<br>第二个参数：相对哪个坐标系旋转，不填默认为相对自己坐标系旋转</li>
</ol>
<pre><code class="c#">this.transform.Rotate(new Vector(0, 10 * Time.deltaTime, 0));
相对世界坐标系旋转
this.transform.Rotate(new Vector(0, 10 * Time.deltaTime, 0), Space.World);
相对自己坐标系旋转
this.transform.Rotate(new Vector(0, 10 * Time.deltaTime, 0), Space.Self);
</code></pre>
<p>相对于某个轴转多少度<br>参数一：相对与哪个轴<br>参数二：旋转速度<br>参数三：相对哪个坐标系旋转，不填默认为相对自己坐标系旋转<br>比如这个，就是相对于自己向上的轴自转</p>
<pre><code class="c#">this.transform.rotate(Vector3.up, 10*Time.deltaTime, Space.Self);
</code></pre>
<p>相对于某个点旋转<br>参数一：某个点<br>参数二：这个点的某个轴<br>参数三：旋转速度</p>
<pre><code class="c#">this.transform.RotateAround(Vector3.Zero, Vector3.Up, 10 * Time.deltaTime);
</code></pre>
<h2 id="三、缩放和看向"><a href="#三、缩放和看向" class="headerlink" title="三、缩放和看向"></a>三、缩放和看向</h2><h3 id="1-缩放"><a href="#1-缩放" class="headerlink" title="1.缩放"></a>1.缩放</h3><pre><code class="c#">相对世界坐标系
print(this.transform.lossyScale);
相对于本地坐标系（父对象）
print(this.transform.localScale);
放大对象
this.transform.localScale += Vector3.one * Time.deltaTime;
</code></pre>
<p>注意：</p>
<ul>
<li>修改缩放，不能只改xyz，必须一起改。</li>
<li>Unity没有提供关于缩放的API。</li>
<li>相对于世界坐标系的缩放，只能得不能改</li>
</ul>
<h3 id="2-看向"><a href="#2-看向" class="headerlink" title="2.看向"></a>2.看向</h3><p>让一个对象的面朝向，可以一直看向某一个点或某一个对象，也就是Z轴方向会对准某个点</p>
<ol>
<li>看向一个点，相对于世界坐标系</li>
</ol>
<pre><code class="c#">this.transform.LookAt(Vector3.zero);                        //参数传入一个点，物体会看向这个点
</code></pre>
<ol start="2">
<li>看向一个对象</li>
</ol>
<pre><code class="c#">this.transform.LookAt(obj.transform);               //传入一个对象的transform，会看向这个对象
</code></pre>
<h2 id="四、父子关系"><a href="#四、父子关系" class="headerlink" title="四、父子关系"></a>四、父子关系</h2><h3 id="1-获取和设置父对象"><a href="#1-获取和设置父对象" class="headerlink" title="1.获取和设置父对象"></a>1.获取和设置父对象</h3><ol>
<li>获取父对象</li>
</ol>
<pre><code class="c#">this.transform.parent                //得到父对象的transform
</code></pre>
<ol start="2">
<li>设置父对象   断绝父子关系</li>
</ol>
<pre><code class="c#">this.transform.parent = null;       
</code></pre>
<ol start="3">
<li>设置父对象   认爸爸</li>
</ol>
<pre><code class="c#">this.transform.parent = 要设置为父对象的transform
</code></pre>
<ol start="4">
<li>通过API进行父子关系设置</li>
</ol>
<pre><code class="c#">this.transform.SetParent(null);                                        //断绝父子关系
this.transform.SetParent(要设置为父对象的transform);        //认爸爸
//参数一：我的父亲
//参数二：是否保留世界坐标的位置、角度、缩放状态
//ture  会保留世界坐标系下的状态 并与 父对象 进行计算 得到本地坐标系的信息
//false 不会保留世界坐标系的状态 并且 将世界坐标系位置、角度和缩放信息直接赋值到本地坐标系下
this.transform.SetParent(要设置为父对象的transform, true); 
</code></pre>
<h3 id="2-舍弃子对象"><a href="#2-舍弃子对象" class="headerlink" title="2.舍弃子对象"></a>2.舍弃子对象</h3><p>断绝自己所有的子对象</p>
<pre><code class="c#">this.transform.DetachChildren();
</code></pre>
<h3 id="3-获取子对象"><a href="#3-获取子对象" class="headerlink" title="3.获取子对象"></a>3.获取子对象</h3><ol>
<li>按名字查找<br>找到子对象的transform，失活的对象也能找到，但子对象的子对象找不到</li>
</ol>
<pre><code class="c#">this.transform.Find(&quot;这个物体的子对象的名字&quot;);               
</code></pre>
<ol start="2">
<li>遍历儿子<br>失活的子对象也可以找到，子对象的子对象找不到<br>注意：在面板上从上到下排列的子对象，编号也是逐渐变大</li>
</ol>
<pre><code class="c#">this.transform.childCount                //子对象的数量
for(int i = 0; i &lt; this.transform.childCount; i++)
&#123;
        print(this.transform.GetChild(i).name);                 //若传入的参数超出范围，则会报错
&#125;
</code></pre>
<h3 id="4-儿子的操作"><a href="#4-儿子的操作" class="headerlink" title="4.儿子的操作"></a>4.儿子的操作</h3><ol>
<li>判断自己的父对象是谁</li>
</ol>
<pre><code class="c#">this.transform.IsChildOf();                //参数填父对象的transform，返回一个bool值
</code></pre>
<ol start="2">
<li>得到自己作为子对象的编号</li>
</ol>
<pre><code class="c#">print(this.transform.GetSiblingIndex());
</code></pre>
<ol start="3">
<li>把自己设置成第一个子对象</li>
</ol>
<pre><code class="c#">this.transform.SetAsFirstSibling();
</code></pre>
<ol start="4">
<li>把自己设置成最后一个子对象</li>
</ol>
<pre><code class="c#">this.transform.SetAsLastSibling();
</code></pre>
<ol start="5">
<li>把自己设置为指定编号的子对象</li>
</ol>
<pre><code class="c#">//传入一个整形，表示指定编号，若超出范围，会设置成最后一个编号，若设置负数，则是最后一个编号
this.transform.SetSiblingIndex(1);     
</code></pre>
<h2 id="五、坐标转换"><a href="#五、坐标转换" class="headerlink" title="五、坐标转换"></a>五、坐标转换</h2><h3 id="1-世界坐标转本地坐标"><a href="#1-世界坐标转本地坐标" class="headerlink" title="1.世界坐标转本地坐标"></a>1.世界坐标转本地坐标</h3><ol>
<li>世界坐标系的点  转换为  相对本地坐标系的点<br>比如  将一个相对于世界坐标系点(0, 0, 1)  转换成  相对于本地坐标系的点的信息<br>受到缩放影响</li>
</ol>
<pre><code class="c#">this.transform.InverseTransformPoint(Vector3.forward);            //传入一个Vector3类型的参数
</code></pre>
<ol start="2">
<li>世界坐标系的方向向量 转换为 相对本地坐标系的方向向量</li>
</ol>
<pre><code class="c#">不受缩放影响
print(this.transform.InverseTransformDirection(Vector3.forward));        //传入一个Vector3
受缩放影响
print(this.transform.InverseTransformVector(Vector.forward));                //传入一个Vector3
</code></pre>
<h3 id="2-本地坐标转世界坐标"><a href="#2-本地坐标转世界坐标" class="headerlink" title="2.本地坐标转世界坐标"></a>2.本地坐标转世界坐标</h3><ol>
<li>相对本地坐标的点 转 相对世界坐标点（常用）<br>收到缩放影响</li>
</ol>
<pre><code class="c#">print(this.transform.TransformPoint(Vector3.forward));        //传入一个Vector3
</code></pre>
<ol start="2">
<li>相对本地坐标系的方向 转 相对世界坐标系的方向</li>
</ol>
<pre><code class="c#">//不受缩放影响
print(this.transform.TransformDirection(Vector3.forward));        //传入一个Vector3
//受缩放影响
print(this.transform.TransformVector(Vector.forward));           //传入一个Vector3       
</code></pre>
<h1 id="知识点四-核心系统"><a href="#知识点四-核心系统" class="headerlink" title="知识点四 核心系统"></a>知识点四 核心系统</h1><h2 id="一、光源系统基础"><a href="#一、光源系统基础" class="headerlink" title="一、光源系统基础"></a>一、光源系统基础</h2><h3 id="1-光源组件"><a href="#1-光源组件" class="headerlink" title="1.光源组件"></a>1.光源组件</h3><ol>
<li>Type（光源类型）<br>1.1Spot（聚光灯）<br>Range（发光范围）<br>Spot Angle（光锥角度）<br>1.2Directional（方向光，环境光）<br>1.3Point（点光源）<br>Range（发光范围）<br>1.4Area（面光源，只能烘焙）<br>烘焙指预先计算好光的效果，然后形成一个贴图，不能实时计算改变，可以节约性能</li>
<li>Color（颜色）</li>
<li>Mode（模式）<br>Realtime（实时光源）<br>每帧实时计算，效果好，性能消耗大<br>Baked（烘焙光源）<br>事先计算好，无法动态变化<br>Mixed（混合光源）<br>预先计算+实时烘焙</li>
<li>Intensity（光源亮度）</li>
<li>Indirect Multiplier（改变间接光的强度）<br>小于1，每次反弹会使光更暗<br>大于1，每次反弹会使光更亮</li>
<li>Shadow Type（阴影类型）<br>NoShadow（关闭阴影）<br>HardShadow（生硬阴影）<br>有锯齿，节约性能<br>SoftShadow（柔和阴影）<br>效果最好</li>
<li>RealtimeShadow（阴影参数）<br>Strength 阴影暗度0~1之间，越大越暗<br>Resolution 阴影贴图渲染分辨率，越高越真是，性能消耗越大<br>Bias 阴影推离光源的距离<br>Normal Bias 阴影投射面沿法线收缩的距离<br>Normal Panel 渲染阴影的近裁剪面</li>
<li>Cookie（投影遮罩）<br>一般用于聚光灯，可以拖入一个贴图，聚光灯的投影会呈现出贴图上的效果<br>贴图黑色部分透明，白色部分有颜色</li>
<li>Cookie Size（遮罩尺寸）<br>只有方向光才能使用，设置遮罩大小</li>
<li>Draw Halo（球形光环开关）<br>类似光晕的效果</li>
<li>Flare（耀斑）<br>如果游戏摄像机看不到耀斑效果，就需要在摄像机上增加一个Flare Layer组件</li>
<li>Render Mode（渲染优先级）<br>Auto 运行时确定<br>Important 以像素质量为单位进行渲染，效果逼真，消耗大<br>Not Important 以快速模式渲染</li>
<li>Culling Mask（剔除遮罩层）<br>决定哪些层的对象受到该光源的影响</li>
<li>代码控制<br>都是成员的变量，方法很少</li>
</ol>
<h3 id="2-光源面板"><a href="#2-光源面板" class="headerlink" title="2.光源面板"></a>2.光源面板</h3><ol>
<li>Environment（环境相关）<br>1.1 Skybox Material（天空盒材质）<br>可以改变天气</li>
</ol>
<p>1.2 Sun Source（太阳来源）<br>不设置默认使用场景中最亮的方向光代表太阳</p>
<p>1.3 Environment Lighting（环境光设置）</p>
<p>1.3.1 Source（来源）<br>Skybox 天空和材质作为环境光颜色        <br>Gradient 为天空、地平线、地面单独选择颜色和他们之间混合</p>
<p>1.3.2 Intensity Multiplier（环境光亮度）</p>
<p>1.4 Ambient Mode（全局光照模式）<br>只有启用实时全局和全局烘焙才有用<br>Realtime（已弃用）<br>baked<br>2. Other Settings<br>2.1 Fog（雾开关）<br>Color 雾颜色<br>Mode 雾模式<br>三种模式：</p>
<ul>
<li>Linear（线性模式，Start离摄像机多远开始有雾，End离摄像机多远完全遮挡）</li>
<li>Exponential（随距离指数增加，Density强度）</li>
<li>Exponential Qquare（随距离比指数更快地增加，Density强度）</li>
</ul>
<p>2.2 Halo Texture（光源周围围着的光环纹理）<br>2.3 Halo Strength（光环的可见性）<br>2.4 Flare Fade Speed（耀斑淡出时间）<br>2.5 Flare Strength（耀斑可见性）<br>2.6 Spot Cookie（聚光灯剪影纹理）</p>
<h2 id="二、物理系统之碰撞检测"><a href="#二、物理系统之碰撞检测" class="headerlink" title="二、物理系统之碰撞检测"></a>二、物理系统之碰撞检测</h2><h3 id="1-刚体RigidBody"><a href="#1-刚体RigidBody" class="headerlink" title="1.刚体RigidBody"></a>1.刚体RigidBody</h3><p>碰撞产生的必要条件：两个物体都具有碰撞器 且 至少一个物体有刚体<br>一个物体有了刚体Rigid Body，就可以产生力的作用</p>
<ol>
<li>Mass（质量）<br>默认为千克<br>质量越大，惯性越大</li>
<li>Drag（空气阻力）<br>根据力移动对象时影响对象的空气阻力大小<br>0表示没有空气阻力</li>
<li>Angular Drag（角度的空气阻力）<br>根据扭矩旋转对象时，影响对象的空气阻力大小，0表示没有空气阻力</li>
<li>Use Gravity（是否受重力影响）</li>
<li>Is Kinematic（是否开启运动学）<br>如果启用，则对象不会被物理引擎驱动<br>只能通过 Transform 对其进行操作。<br>对于移动平台，或者如果要动画化附加了 HingeJoint 的刚体，此属性将非常有用</li>
<li>Interpolate（插值运算）<br>让刚体物体移动更加平滑<br>如果想要将物理帧更新时间变长，则非常有用<br>6.1 None（不应用插值运算）<br>6.2 Interpolate（根据前一帧的变化来平滑变化）<br>6.3 Extrapolate（差值运算，根据下一帧的估计变化来平滑变化）</li>
<li>Collision Detection（碰撞检测模式）<br>用于防止快速移动的对象穿过其他对象而不检测碰撞<br>7.1 Discrete（离散检测）（这是默认值）<br>对场景中的所有其他碰撞体使用离散碰撞检测。<br>其他碰撞体在测试碰撞时，会使用离散碰撞检测。<br>用于正常碰撞</li>
</ol>
<p>7.2 Continuous（连续检测）<br>对动态碰撞体（具有刚体）使用离散检测<br>并对静态碰撞体（没有刚体）使用连续碰撞检测<br>设置为连续动态（Continuous Dynamic）的刚体将在测试与该刚体的碰撞时使用连续碰撞检测。（此属性对物理性能有很大影响，如果没有快速对象的碰撞问题，请将其保留为Discrete）<br>其他刚体将使用离散碰撞检测</p>
<p>7.3 Continuous Dynamic（连续动态检测，性能消耗高）<br>对设置为连续（Continuous）和连续动态（Continuous Dynamic）碰撞的游戏对象使用连续碰撞检测时。还将对静态碰撞体（没有刚体）使用连续碰撞检测。<br>对于所有其他碰撞体，使用离散碰撞检测，用于快速移动的对象</p>
<p>7.4 Continuous Speculative（连续推测检测）<br>对刚体和碰撞体使用推测性连续碰撞检测，该方法通常比连续碰撞检测成本更低<br>8. Constraints（约束）<br>对刚体运动的限制<br>8.1 Freeze Position<br>有选择的停止刚体沿X、Y、Z轴移动<br>8.2 Freeze Rotation<br>有选择的停止刚体沿X、Y、Z轴旋转<br>9. Info<br>调试时看的参数，一般不修改</p>
<h3 id="2-物理材质Material"><a href="#2-物理材质Material" class="headerlink" title="2.物理材质Material"></a>2.物理材质Material</h3><ol>
<li>创建物理材质<br>Project窗口右键 ——&gt; Create ——&gt; Physic Material </li>
<li>物理材质的参数<br>2.1 Dynamic Friction（动态摩擦力）<br>已在移动时使用的摩擦力。<br>通常为0到1之间的值。<br>值为0时就像冰一样，值为1将导致物体很难移动，除非用很大的力</li>
</ol>
<p>2.2 Static Friction（静态摩擦力）<br>对象静止在表面时使用的摩擦力<br>通常为0到1之间的值。<br>值为0时就像冰一样，值为1将导致物体很难移动。</p>
<p>2.3 Bounciness（弹性）<br>表面的弹性如何<br>值为0则不反弹，值为1则反弹时不产生能量损失，预计会有一些近似值，但可能只会给模拟增加少量能量</p>
<p>2.4 Friction Combine（两个碰撞对象的摩擦力组合方式）<br>Average（对两个摩擦值求平均值）<br>Minimum（使用两个值中的最小值）<br>Maximum（使用两个值中的最大值）<br>Multiply（两个摩擦值相乘）</p>
<p>2.5 unce Combine（两个碰撞对象的弹力组合方式）<br>其模式与 Friction Combine 相同</p>
<h3 id="3-碰撞检测函数"><a href="#3-碰撞检测函数" class="headerlink" title="3.碰撞检测函数"></a>3.碰撞检测函数</h3><p>注意：碰撞和触发响应函数（处于FixedUpdate之后，触发的频率与FixedUpdate相关） 属于 特殊的生命周期函数 也是通过反射调用 </p>
<ol>
<li>物理碰撞检测响应函数<br>碰撞触发接触时，自动执行这个函数<br>注意：名字和返回值都不能改变</li>
</ol>
<pre><code class="c#">private void OnCollisionEnter(Collision collision)      //Collision对象名字可改，代表碰到我的对象
&#123;

&#125;

//碰撞结束分离时会自动执行的函数
private void OnCollisionExit(Collision collision)           //Collision对象名字可改，代表碰到我的对象
&#123;

&#125;

//两个物体接触且摩擦时，会不停地调用该函数
private void OnCollisionStay(Collision collision)      //Collision对象名字可改，代表碰到我的对象
&#123;

&#125;
</code></pre>
<p>传入的Collision类型的参数的信息</p>
<pre><code class="c#">//a.碰到的对象的碰撞器信息
collision.colllider
//b.碰到的对象的GameObject
collision.gameObject
//c.碰撞对象的依附对象的位置信息
collision.transform
//d.碰撞对象的触碰点数相关
collision.contactCount
//e.碰撞对象的接触点坐标
ContactPoint[ ] A =  collision.contacts;        //是一个数组
</code></pre>
<ol start="2">
<li>触发器检测响应函数</li>
</ol>
<pre><code class="c#">//第一次接触时，会自动调用
private void OnTriggerEnter(Collider other)
&#123;

&#125;

//当相融的状态结束时，调用一次
private void OnTriggerExit(Collider other)
&#123;

&#125;

//当相融时，会不停调用
private void OnTriggerStay(Collider other)
&#123;

&#125;
</code></pre>
<ol start="3">
<li>要明确什么时候会响应函数</li>
</ol>
<ul>
<li>只要挂载的对象，能和别的物体产生碰撞或者触发，那么对应的这6个函数，就能被响应。</li>
<li>根据需求选择写哪个函数。</li>
<li>如果是一个异形物体，在子物体上挂载脚本进行碰撞检测是不行的，必须挂载到这个刚体的父对象上才有效果。</li>
<li>明确物理碰撞和触发器触发响应的区别</li>
</ul>
<ol start="4">
<li>碰撞和触发器函数都可以写成虚函数，在子类中重写<br>一般不会将 碰撞和触发函数 写成public，若想要重写，写成protected</li>
</ol>
<h3 id="4-刚体加力"><a href="#4-刚体加力" class="headerlink" title="4.刚体加力"></a>4.刚体加力</h3><ol>
<li>刚体自带添加力的方法<br>给刚体加力的目标是<br>让其有一个初速度 朝某一方向移动</li>
</ol>
<p>1.1 首先获取刚体组件</p>
<pre><code class="c#">Rigidbody rigidBody = this.GetComponent&lt;Rigidbody&gt;();
</code></pre>
<p>1.2 添加力<br>如果希望一直给对象施加力，则一直“推”<br>相对世界坐标<br>参数一：力的方向和大小<br>参数二：力的模式</p>
<pre><code class="c#">rigidBody.AddForce(Vector3.Forward * 10);                //世界坐标系Z轴正方向加了力
相对本地坐标系
rigidBody.AddRelativeForce(Vector3.Forward * 10);        //向本地坐标系的Z轴正方形施加力
</code></pre>
<p>1.3 添加扭矩力，让其旋转</p>
<pre><code class="c#">//相对世界坐标系
rigidBody.AddTorque(Vector3.up * 10);                //绕世界坐标系的y轴有扭矩力
//相对本地坐标系
rigidBody.AddRelativeTorque(Vector3.up * 10);        //绕本地坐标系的y轴有扭矩力
</code></pre>
<p>1.4直接改变速度</p>
<pre><code class="c#">rigidBody.velocity = Vector3.forward * 5;
</code></pre>
<p>1.5模拟爆炸的效果<br>所有希望产生爆炸效果的物体，要得到所有要模拟爆炸效果的物体的刚体，然后调用这个方法<br>参数一：力的大小<br>参数二：爆炸的中心，是相对世界坐标系的<br>参数三：半径</p>
<pre><code class="c#">rigidBody.AddExplosionForce(10, Vector3.zero, 10);
</code></pre>
<ol start="2">
<li>力的几种模式<br>参数二就是选择力的模式</li>
</ol>
<pre><code class="c#">rigidBody.AddForce(Vector3.forward * 10, ForceMode.Acceleration);
</code></pre>
<p>动量定理<br>Ft &#x3D; mv<br>v &#x3D; Ft&#x2F;m</p>
<p>2.1 Acceleration（动量模式）<br>给物体增加一个持续的加速度，忽略其质量<br>v &#x3D; Ft&#x2F;m<br>F: (0, 0, 10)<br>t &#x3D; 0.02s          &#x2F;&#x2F;物理帧更新时间决定<br>m: 默认为1<br>v &#x3D; (10 * 0.02) &#x2F; 1 &#x3D; 0.2 m&#x2F;s <br>每物理帧移动0.2 m&#x2F;s * 0.02s &#x3D; 0.004m</p>
<p>2.2 Force<br>给物体增加一个持续的力，与其质量有关<br>v &#x3D; Ft&#x2F;m<br>F: (0, 0, 10)<br>t &#x3D; 0.02s          &#x2F;&#x2F;物理帧更新时间决定<br>m: 2kg        &#x2F;&#x2F;质量可以改变<br>v &#x3D; (10 * 0.02) &#x2F; 2 &#x3D; 0.1 m&#x2F;s <br>每物理帧移动0.1 m&#x2F;s * 0.02s &#x3D; 0.002m</p>
<p>2.3 Impulse<br>给物体增加一个瞬间的力，与其质量有关，忽略时间，默认为1<br>v &#x3D; Ft&#x2F;m<br>F: (0, 0, 10)<br>t &#x3D; 默认为1<br>m: 2kg        &#x2F;&#x2F;质量可以改变<br>v &#x3D; (10 * 1) &#x2F; 2 &#x3D; 5 m&#x2F;s <br>每物理帧移动 5 m&#x2F;s * 0.02s &#x3D; 0.1m</p>
<p>2.4 VelocityChange<br>给物体添加一个瞬时速度，忽略质量和时间，只和力有关<br>v &#x3D; Ft&#x2F;m<br>F: (0, 0, 10)<br>t &#x3D; 默认为1<br>m: 默认为1<br>v &#x3D; (10 * 1) &#x2F; 1 &#x3D; 10 m&#x2F;s <br>每物理帧移动 5 m&#x2F;s * 0.02s &#x3D; 0.2m</p>
<ol start="3">
<li><p>力场脚本<br>脚本名：Constant Force<br>可以在 Inspector 窗口为物体直接添加一个力，自己设置参数控制物体受力的方向和大小</p>
</li>
<li><p>刚体的休眠<br>为了节约性能，刚体在某些情况下会进行休眠<br>若休眠，此时可以</p>
</li>
</ol>
<pre><code class="c#">if( rigidBody.IsSleeping() )
&#123;
    rigidBody.WakeUp();
&#125;
</code></pre>
<h2 id="三、音效系统"><a href="#三、音效系统" class="headerlink" title="三、音效系统"></a>三、音效系统</h2><h3 id="1-音频文件导入"><a href="#1-音频文件导入" class="headerlink" title="1.音频文件导入"></a>1.音频文件导入</h3><p>常用格式：wav、mp3、ogg、aiff</p>
<h3 id="2-音频源和音频监听脚本"><a href="#2-音频源和音频监听脚本" class="headerlink" title="2.音频源和音频监听脚本"></a>2.音频源和音频监听脚本</h3><ol>
<li>Audio Source 音频源<br>1.1如何为一个物体添加 AudioSource 音频源脚本：<br>点击物体 ——&gt; Add Component ——&gt; AudioSource</li>
</ol>
<p>1.2 AudioClip （声音剪辑文件）<br>也就是音频文件，将音频文件拖上去即可关联</p>
<p>1.3 Output<br>作为一个输出的设置<br>默认将直接输出到场景的音频监听器，可以更改为输出到混音器</p>
<p>1.4 Mute（静音开关）</p>
<p>1.5 Bypass Effect（开关滤波器效果）</p>
<p>1.6 Bypass Listener Effect（快速开关所有监听器）</p>
<p>1.7 Bypass Reverb Zones（快速开关所有混响区）</p>
<p>1.8 Play On Awake（对象创建时就播放音乐）<br>开关启动游戏就播放</p>
<p>1.9 Loop（循环）<br>是否循环</p>
<p>1.10 Priority（优先级）<br>0最高，128最低，多个音频同时播放时，优先级越高越不容易被擦除</p>
<p>1.11 Volume（音量大小）<br>0最小，1最大</p>
<p>1.12 Pitch（音高）</p>
<p>1.13 Stereo Pan（立体声平移）<br>2D声音立体声位置，相当于左右声道</p>
<p>1.14 Spatial Blend（空间混合）<br>音频受3D空间的影响程度<br>音效默认是2D音效，不论怎么移动，声音都一样大，而3D音效则是有近大远小的概念</p>
<p>1.15 Reverb Zone Mix（混响区混音）<br>到混响区的输出信号量</p>
<p>1.16 3D Sound Setting（3D音效设置，和 Spatial Blend 参数成正比）<br>Doppler Level（多普勒效果等级）<br>Spread（扩散角度设置为3D立体声还是多声道）<br>Volume Rolloff（声音的衰减速度）<br>        Logarithmic Rolloff：靠近音频源时，声音很大，但离开对象时，声音降低得非常快<br>        Linear Rolloff：与音频源的距离越远，听到的声音越小，成正比<br>        Custom Rolloff：音频源的音频效果是根据曲线的设置变化的<br>Min&#x2F;Max Distance（最小距离内，声音保持最大响度，最大距离外，声音消失）</p>
<ol start="2">
<li>Audio Listener 音频监听脚本<br>收听音频的组件<br>一般挂载在摄像机上，摄像机一创建就会自带这个组件<br>场景上必须只能有一个，才能正常工作</li>
</ol>
<h3 id="3-代码控制音频源"><a href="#3-代码控制音频源" class="headerlink" title="3.代码控制音频源"></a>3.代码控制音频源</h3><ol>
<li>代码控制播放停止</li>
</ol>
<pre><code class="c#">AudioSource audioSource = this.GetComponent&lt;AudioSource&gt;();        //得到自己的音频源组件
audioSource.Play();                        //播放
audioSource.PlayDelayed(5);     //延迟5秒后播放
audioSource.Stop();                        //停止
audioSource.Pause();                      //暂停
audioSource.UnPause();                  //停止暂停
</code></pre>
<ol start="2">
<li>如何检测音效播放完毕</li>
</ol>
<pre><code class="c#">if ( audioSource.isPlaying )        //若音效在播放，则返回true
&#123;

&#125;
</code></pre>
<ol start="3">
<li>如何动态控制音效播放<br>3.1直接在要播放音效的对象上挂载脚本 控制播放<br>3.2实例化挂载了音效源脚本的对象<br>在音效源组件上勾选 Play On Awake，若想播放，则直接实例化。</li>
</ol>
<pre><code class="c#">Instantiate(obj);
</code></pre>
<p>3.3用一个 AudioSource 来控制播放不同的音效<br>比如</p>
<pre><code class="c#">public AudioClip clip;
AudioSource aus = this.gameObject.AddComponent&lt;AudioSource &gt;();
aus.clip = clip;
aus.Play();
</code></pre>
<h3 id="4-麦克风输入相关"><a href="#4-麦克风输入相关" class="headerlink" title="4.麦克风输入相关"></a>4.麦克风输入相关</h3><ol>
<li>获取设备麦克风信息</li>
</ol>
<pre><code class="c#">string[ ] strs = Microphone.devices;    //所有麦克风设备的名字的字符串数组
</code></pre>
<ol start="2">
<li>开始录制<br>参数一：设备名字 传空就使用默认设备<br>参数二：超过录制长度后 是否重头录制<br>参数三：录制时长（单位秒）<br>参数四：采样率（一般填44100）</li>
</ol>
<pre><code class="c#">Microphone.Start(null, false, 5, 44100);    //返回一个AudioClip文件
</code></pre>
<ol start="3">
<li>结束录制<br>参数一：设备名字 传空就使用默认值</li>
</ol>
<pre><code class="c#">Microphone.End(null);
</code></pre>
<ol start="4">
<li>获取音频数据用于存储或传输<br>先声明一个float数组，数组的长度必须是这两个相乘（声道数 * 剪辑长度）</li>
</ol>
<pre><code class="c#">float[ ] f = new float[ audioClip.channels * audioClip.samples ];
//参数一：要存的数组（float数组）
//参数二：偏移的位置，默认填0
audioClip.GetData(f, 0);
</code></pre>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 jaytp@qq.com </span>
    </div>
</article>







    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2024 Paul
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 562px;
    }
    .nav.fullscreen {
        margin-left: -562px;
    }
    .nav-left {
        width: 140px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 512px;
        }
        .nav.fullscreen {
            margin-left: -512px;
        }
        .nav-left {
            width: 120px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 512px;
            margin-left: -512px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
